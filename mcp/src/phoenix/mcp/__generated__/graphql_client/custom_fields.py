# Generated by ariadne-codegen

from typing import Any, Dict, Optional, Union

from . import DataQualityMetric, InferencesRole, ScalarDriftMetric, VectorDriftMetric
from .base_operation import GraphQLField
from .custom_typing_fields import (
    AnnotationGraphQLField,
    AnnotationSummaryGraphQLField,
    ApiKeyGraphQLField,
    BinUnion,
    BooleanInvocationParameterGraphQLField,
    BoundedFloatInvocationParameterGraphQLField,
    ChatCompletionFunctionCallGraphQLField,
    ChatCompletionMutationErrorGraphQLField,
    ChatCompletionMutationPayloadChatCompletionMutationErrorUnion,
    ChatCompletionMutationPayloadGraphQLField,
    ChatCompletionOverDatasetMutationExamplePayloadGraphQLField,
    ChatCompletionOverDatasetMutationPayloadGraphQLField,
    ChatCompletionToolCallGraphQLField,
    ClusterGraphQLField,
    ContentPartUnion,
    CreateSystemApiKeyMutationPayloadGraphQLField,
    CreateUserApiKeyMutationPayloadGraphQLField,
    DataQualityTimeSeriesGraphQLField,
    DatasetConnectionGraphQLField,
    DatasetEdgeGraphQLField,
    DatasetExampleConnectionGraphQLField,
    DatasetExampleEdgeGraphQLField,
    DatasetExampleGraphQLField,
    DatasetExampleRevisionGraphQLField,
    DatasetGraphQLField,
    DatasetMutationPayloadGraphQLField,
    DatasetValuesGraphQLField,
    DatasetVersionConnectionGraphQLField,
    DatasetVersionEdgeGraphQLField,
    DatasetVersionGraphQLField,
    DbTableStatsGraphQLField,
    DeleteApiKeyMutationPayloadGraphQLField,
    DeletePromptMutationPayloadGraphQLField,
    DimensionConnectionGraphQLField,
    DimensionEdgeGraphQLField,
    DimensionGraphQLField,
    DimensionWithValueGraphQLField,
    DocumentEvaluationGraphQLField,
    DocumentEvaluationSummaryGraphQLField,
    DocumentRetrievalMetricsGraphQLField,
    DriftTimeSeriesGraphQLField,
    EmbeddingDimensionConnectionGraphQLField,
    EmbeddingDimensionEdgeGraphQLField,
    EmbeddingDimensionGraphQLField,
    EmbeddingMetadataGraphQLField,
    EventGraphQLField,
    EventMetadataGraphQLField,
    ExampleRevisionGraphQLField,
    ExperimentAnnotationSummaryGraphQLField,
    ExperimentComparisonGraphQLField,
    ExperimentConnectionGraphQLField,
    ExperimentEdgeGraphQLField,
    ExperimentGraphQLField,
    ExperimentMutationPayloadGraphQLField,
    ExperimentRunAnnotationConnectionGraphQLField,
    ExperimentRunAnnotationEdgeGraphQLField,
    ExperimentRunAnnotationGraphQLField,
    ExperimentRunConnectionGraphQLField,
    ExperimentRunEdgeGraphQLField,
    ExperimentRunGraphQLField,
    ExportedFileGraphQLField,
    FloatInvocationParameterGraphQLField,
    FunctionalityGraphQLField,
    GenerativeModelGraphQLField,
    GenerativeProviderGraphQLField,
    InferencesGraphQLField,
    IntervalBinGraphQLField,
    IntInvocationParameterGraphQLField,
    InvocationParameterBaseGraphQLField,
    InvocationParameterUnion,
    JSONInvocationParameterGraphQLField,
    LabelFractionGraphQLField,
    MissingValueBinGraphQLField,
    ModelGraphQLField,
    NodeGraphQLField,
    NominalBinGraphQLField,
    NumericRangeGraphQLField,
    PageInfoGraphQLField,
    PerformanceTimeSeriesGraphQLField,
    Point2DGraphQLField,
    Point2DPoint3DUnion,
    Point3DGraphQLField,
    ProjectConnectionGraphQLField,
    ProjectEdgeGraphQLField,
    ProjectGraphQLField,
    ProjectSessionConnectionGraphQLField,
    ProjectSessionEdgeGraphQLField,
    ProjectSessionGraphQLField,
    PromptChatTemplateGraphQLField,
    PromptConnectionGraphQLField,
    PromptEdgeGraphQLField,
    PromptGraphQLField,
    PromptLabelConnectionGraphQLField,
    PromptLabelEdgeGraphQLField,
    PromptLabelGraphQLField,
    PromptLabelMutationPayloadGraphQLField,
    PromptMessageGraphQLField,
    PromptResponseGraphQLField,
    PromptStringTemplateGraphQLField,
    PromptTemplateUnion,
    PromptVersionConnectionGraphQLField,
    PromptVersionEdgeGraphQLField,
    PromptVersionGraphQLField,
    PromptVersionTagGraphQLField,
    PromptVersionTagMutationPayloadGraphQLField,
    QueryGraphQLField,
    ResponseFormatGraphQLField,
    RetrievalGraphQLField,
    RunComparisonItemGraphQLField,
    SegmentGraphQLField,
    SegmentsGraphQLField,
    SpanAnnotationGraphQLField,
    SpanAnnotationMutationPayloadGraphQLField,
    SpanAsExampleRevisionGraphQLField,
    SpanConnectionGraphQLField,
    SpanContextGraphQLField,
    SpanEdgeGraphQLField,
    SpanEventGraphQLField,
    SpanGraphQLField,
    SpanIOValueGraphQLField,
    StringInvocationParameterGraphQLField,
    StringListInvocationParameterGraphQLField,
    SystemApiKeyGraphQLField,
    TextContentPartGraphQLField,
    TextContentValueGraphQLField,
    TimeSeriesDataPointGraphQLField,
    TimeSeriesGraphQLField,
    TokenUsageGraphQLField,
    ToolCallContentPartGraphQLField,
    ToolCallContentValueGraphQLField,
    ToolCallFunctionGraphQLField,
    ToolDefinitionGraphQLField,
    ToolResultContentPartGraphQLField,
    ToolResultContentValueGraphQLField,
    TraceAnnotationGraphQLField,
    TraceAnnotationMutationPayloadGraphQLField,
    TraceConnectionGraphQLField,
    TraceEdgeGraphQLField,
    TraceGraphQLField,
    UMAPPointGraphQLField,
    UMAPPointsGraphQLField,
    UserApiKeyGraphQLField,
    UserConnectionGraphQLField,
    UserEdgeGraphQLField,
    UserGraphQLField,
    UserMutationPayloadGraphQLField,
    UserRoleGraphQLField,
    ValidationResultGraphQLField,
)
from .input_types import (
    ClusterInput,
    DataQualityMetricInput,
    DatasetSort,
    DatasetVersionSort,
    DimensionFilter,
    DimensionInput,
    Granularity,
    InputCoordinate2D,
    InputCoordinate3D,
    ModelsInput,
    PerformanceMetricInput,
    ProjectSessionSort,
    SpanAnnotationSort,
    SpanSort,
    TimeRange,
    TraceAnnotationSort,
)


class AnnotationInterface(GraphQLField):
    name: "AnnotationGraphQLField" = AnnotationGraphQLField("name")
    score: "AnnotationGraphQLField" = AnnotationGraphQLField("score")
    label: "AnnotationGraphQLField" = AnnotationGraphQLField("label")
    explanation: "AnnotationGraphQLField" = AnnotationGraphQLField("explanation")

    def fields(self, *subfields: AnnotationGraphQLField) -> "AnnotationInterface":
        """Subfields should come from the AnnotationInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AnnotationInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "AnnotationInterface":
        self._inline_fragments[type_name] = subfields
        return self


class AnnotationSummaryFields(GraphQLField):
    count: "AnnotationSummaryGraphQLField" = AnnotationSummaryGraphQLField("count")
    labels: "AnnotationSummaryGraphQLField" = AnnotationSummaryGraphQLField("labels")

    @classmethod
    def label_fractions(cls) -> "LabelFractionFields":
        return LabelFractionFields("label_fractions")

    mean_score: "AnnotationSummaryGraphQLField" = AnnotationSummaryGraphQLField(
        "meanScore"
    )
    score_count: "AnnotationSummaryGraphQLField" = AnnotationSummaryGraphQLField(
        "scoreCount"
    )
    label_count: "AnnotationSummaryGraphQLField" = AnnotationSummaryGraphQLField(
        "labelCount"
    )

    def fields(
        self, *subfields: Union[AnnotationSummaryGraphQLField, "LabelFractionFields"]
    ) -> "AnnotationSummaryFields":
        """Subfields should come from the AnnotationSummaryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "AnnotationSummaryFields":
        self._alias = alias
        return self


class ApiKeyInterface(GraphQLField):
    name: "ApiKeyGraphQLField" = ApiKeyGraphQLField("name")
    description: "ApiKeyGraphQLField" = ApiKeyGraphQLField("description")
    created_at: "ApiKeyGraphQLField" = ApiKeyGraphQLField("createdAt")
    expires_at: "ApiKeyGraphQLField" = ApiKeyGraphQLField("expiresAt")

    def fields(self, *subfields: ApiKeyGraphQLField) -> "ApiKeyInterface":
        """Subfields should come from the ApiKeyInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ApiKeyInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "ApiKeyInterface":
        self._inline_fragments[type_name] = subfields
        return self


class BooleanInvocationParameterFields(GraphQLField):
    invocation_name: "BooleanInvocationParameterGraphQLField" = (
        BooleanInvocationParameterGraphQLField("invocationName")
    )
    canonical_name: "BooleanInvocationParameterGraphQLField" = (
        BooleanInvocationParameterGraphQLField("canonicalName")
    )
    label: "BooleanInvocationParameterGraphQLField" = (
        BooleanInvocationParameterGraphQLField("label")
    )
    required: "BooleanInvocationParameterGraphQLField" = (
        BooleanInvocationParameterGraphQLField("required")
    )
    invocation_input_field: "BooleanInvocationParameterGraphQLField" = (
        BooleanInvocationParameterGraphQLField("invocationInputField")
    )
    default_value: "BooleanInvocationParameterGraphQLField" = (
        BooleanInvocationParameterGraphQLField("defaultValue")
    )

    def fields(
        self, *subfields: BooleanInvocationParameterGraphQLField
    ) -> "BooleanInvocationParameterFields":
        """Subfields should come from the BooleanInvocationParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "BooleanInvocationParameterFields":
        self._alias = alias
        return self


class BoundedFloatInvocationParameterFields(GraphQLField):
    invocation_name: "BoundedFloatInvocationParameterGraphQLField" = (
        BoundedFloatInvocationParameterGraphQLField("invocationName")
    )
    canonical_name: "BoundedFloatInvocationParameterGraphQLField" = (
        BoundedFloatInvocationParameterGraphQLField("canonicalName")
    )
    label: "BoundedFloatInvocationParameterGraphQLField" = (
        BoundedFloatInvocationParameterGraphQLField("label")
    )
    required: "BoundedFloatInvocationParameterGraphQLField" = (
        BoundedFloatInvocationParameterGraphQLField("required")
    )
    invocation_input_field: "BoundedFloatInvocationParameterGraphQLField" = (
        BoundedFloatInvocationParameterGraphQLField("invocationInputField")
    )
    default_value: "BoundedFloatInvocationParameterGraphQLField" = (
        BoundedFloatInvocationParameterGraphQLField("defaultValue")
    )
    min_value: "BoundedFloatInvocationParameterGraphQLField" = (
        BoundedFloatInvocationParameterGraphQLField("minValue")
    )
    max_value: "BoundedFloatInvocationParameterGraphQLField" = (
        BoundedFloatInvocationParameterGraphQLField("maxValue")
    )

    def fields(
        self, *subfields: BoundedFloatInvocationParameterGraphQLField
    ) -> "BoundedFloatInvocationParameterFields":
        """Subfields should come from the BoundedFloatInvocationParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "BoundedFloatInvocationParameterFields":
        self._alias = alias
        return self


class ChatCompletionFunctionCallFields(GraphQLField):
    name: "ChatCompletionFunctionCallGraphQLField" = (
        ChatCompletionFunctionCallGraphQLField("name")
    )
    arguments: "ChatCompletionFunctionCallGraphQLField" = (
        ChatCompletionFunctionCallGraphQLField("arguments")
    )

    def fields(
        self, *subfields: ChatCompletionFunctionCallGraphQLField
    ) -> "ChatCompletionFunctionCallFields":
        """Subfields should come from the ChatCompletionFunctionCallFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChatCompletionFunctionCallFields":
        self._alias = alias
        return self


class ChatCompletionMutationErrorFields(GraphQLField):
    message: "ChatCompletionMutationErrorGraphQLField" = (
        ChatCompletionMutationErrorGraphQLField("message")
    )

    def fields(
        self, *subfields: ChatCompletionMutationErrorGraphQLField
    ) -> "ChatCompletionMutationErrorFields":
        """Subfields should come from the ChatCompletionMutationErrorFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChatCompletionMutationErrorFields":
        self._alias = alias
        return self


class ChatCompletionMutationPayloadFields(GraphQLField):
    content: "ChatCompletionMutationPayloadGraphQLField" = (
        ChatCompletionMutationPayloadGraphQLField("content")
    )

    @classmethod
    def tool_calls(cls) -> "ChatCompletionToolCallFields":
        return ChatCompletionToolCallFields("tool_calls")

    @classmethod
    def span(cls) -> "SpanFields":
        return SpanFields("span")

    error_message: "ChatCompletionMutationPayloadGraphQLField" = (
        ChatCompletionMutationPayloadGraphQLField("errorMessage")
    )

    def fields(
        self,
        *subfields: Union[
            ChatCompletionMutationPayloadGraphQLField,
            "ChatCompletionToolCallFields",
            "SpanFields",
        ],
    ) -> "ChatCompletionMutationPayloadFields":
        """Subfields should come from the ChatCompletionMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChatCompletionMutationPayloadFields":
        self._alias = alias
        return self


class ChatCompletionOverDatasetMutationExamplePayloadFields(GraphQLField):
    dataset_example_id: "ChatCompletionOverDatasetMutationExamplePayloadGraphQLField" = ChatCompletionOverDatasetMutationExamplePayloadGraphQLField(
        "datasetExampleId"
    )
    experiment_run_id: "ChatCompletionOverDatasetMutationExamplePayloadGraphQLField" = (
        ChatCompletionOverDatasetMutationExamplePayloadGraphQLField("experimentRunId")
    )
    result: "ChatCompletionMutationPayloadChatCompletionMutationErrorUnion" = (
        ChatCompletionMutationPayloadChatCompletionMutationErrorUnion("result")
    )

    def fields(
        self,
        *subfields: Union[
            ChatCompletionOverDatasetMutationExamplePayloadGraphQLField,
            "ChatCompletionMutationPayloadChatCompletionMutationErrorUnion",
        ],
    ) -> "ChatCompletionOverDatasetMutationExamplePayloadFields":
        """Subfields should come from the ChatCompletionOverDatasetMutationExamplePayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(
        self, alias: str
    ) -> "ChatCompletionOverDatasetMutationExamplePayloadFields":
        self._alias = alias
        return self


class ChatCompletionOverDatasetMutationPayloadFields(GraphQLField):
    dataset_id: "ChatCompletionOverDatasetMutationPayloadGraphQLField" = (
        ChatCompletionOverDatasetMutationPayloadGraphQLField("datasetId")
    )
    dataset_version_id: "ChatCompletionOverDatasetMutationPayloadGraphQLField" = (
        ChatCompletionOverDatasetMutationPayloadGraphQLField("datasetVersionId")
    )
    experiment_id: "ChatCompletionOverDatasetMutationPayloadGraphQLField" = (
        ChatCompletionOverDatasetMutationPayloadGraphQLField("experimentId")
    )

    @classmethod
    def examples(cls) -> "ChatCompletionOverDatasetMutationExamplePayloadFields":
        return ChatCompletionOverDatasetMutationExamplePayloadFields("examples")

    def fields(
        self,
        *subfields: Union[
            ChatCompletionOverDatasetMutationPayloadGraphQLField,
            "ChatCompletionOverDatasetMutationExamplePayloadFields",
        ],
    ) -> "ChatCompletionOverDatasetMutationPayloadFields":
        """Subfields should come from the ChatCompletionOverDatasetMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChatCompletionOverDatasetMutationPayloadFields":
        self._alias = alias
        return self


class ChatCompletionToolCallFields(GraphQLField):
    id: "ChatCompletionToolCallGraphQLField" = ChatCompletionToolCallGraphQLField("id")

    @classmethod
    def function(cls) -> "ChatCompletionFunctionCallFields":
        return ChatCompletionFunctionCallFields("function")

    def fields(
        self,
        *subfields: Union[
            ChatCompletionToolCallGraphQLField, "ChatCompletionFunctionCallFields"
        ],
    ) -> "ChatCompletionToolCallFields":
        """Subfields should come from the ChatCompletionToolCallFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ChatCompletionToolCallFields":
        self._alias = alias
        return self


class ClusterFields(GraphQLField):
    id: "ClusterGraphQLField" = ClusterGraphQLField("id")
    event_ids: "ClusterGraphQLField" = ClusterGraphQLField("eventIds")
    drift_ratio: "ClusterGraphQLField" = ClusterGraphQLField("driftRatio")
    primary_to_corpus_ratio: "ClusterGraphQLField" = ClusterGraphQLField(
        "primaryToCorpusRatio"
    )

    @classmethod
    def data_quality_metric(
        cls, metric: DataQualityMetricInput
    ) -> "DatasetValuesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "DataQualityMetricInput!", "value": metric}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetValuesFields("data_quality_metric", arguments=cleared_arguments)

    @classmethod
    def performance_metric(
        cls, metric: PerformanceMetricInput
    ) -> "DatasetValuesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "PerformanceMetricInput!", "value": metric}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetValuesFields("performance_metric", arguments=cleared_arguments)

    def fields(
        self, *subfields: Union[ClusterGraphQLField, "DatasetValuesFields"]
    ) -> "ClusterFields":
        """Subfields should come from the ClusterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ClusterFields":
        self._alias = alias
        return self


class CreateSystemApiKeyMutationPayloadFields(GraphQLField):
    jwt: "CreateSystemApiKeyMutationPayloadGraphQLField" = (
        CreateSystemApiKeyMutationPayloadGraphQLField("jwt")
    )

    @classmethod
    def api_key(cls) -> "SystemApiKeyFields":
        return SystemApiKeyFields("api_key")

    @classmethod
    def query(cls) -> "QueryFields":
        return QueryFields("query")

    def fields(
        self,
        *subfields: Union[
            CreateSystemApiKeyMutationPayloadGraphQLField,
            "QueryFields",
            "SystemApiKeyFields",
        ],
    ) -> "CreateSystemApiKeyMutationPayloadFields":
        """Subfields should come from the CreateSystemApiKeyMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateSystemApiKeyMutationPayloadFields":
        self._alias = alias
        return self


class CreateUserApiKeyMutationPayloadFields(GraphQLField):
    jwt: "CreateUserApiKeyMutationPayloadGraphQLField" = (
        CreateUserApiKeyMutationPayloadGraphQLField("jwt")
    )

    @classmethod
    def api_key(cls) -> "UserApiKeyFields":
        return UserApiKeyFields("api_key")

    @classmethod
    def query(cls) -> "QueryFields":
        return QueryFields("query")

    def fields(
        self,
        *subfields: Union[
            CreateUserApiKeyMutationPayloadGraphQLField,
            "QueryFields",
            "UserApiKeyFields",
        ],
    ) -> "CreateUserApiKeyMutationPayloadFields":
        """Subfields should come from the CreateUserApiKeyMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "CreateUserApiKeyMutationPayloadFields":
        self._alias = alias
        return self


class DataQualityTimeSeriesFields(GraphQLField):
    @classmethod
    def data(cls) -> "TimeSeriesDataPointFields":
        return TimeSeriesDataPointFields("data")

    def fields(
        self,
        *subfields: Union[
            DataQualityTimeSeriesGraphQLField, "TimeSeriesDataPointFields"
        ],
    ) -> "DataQualityTimeSeriesFields":
        """Subfields should come from the DataQualityTimeSeriesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DataQualityTimeSeriesFields":
        self._alias = alias
        return self


class DatasetFields(GraphQLField):
    id: "DatasetGraphQLField" = DatasetGraphQLField("id")
    name: "DatasetGraphQLField" = DatasetGraphQLField("name")
    description: "DatasetGraphQLField" = DatasetGraphQLField("description")
    metadata: "DatasetGraphQLField" = DatasetGraphQLField("metadata")
    created_at: "DatasetGraphQLField" = DatasetGraphQLField("createdAt")
    updated_at: "DatasetGraphQLField" = DatasetGraphQLField("updatedAt")

    @classmethod
    def versions(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
        sort: Optional[DatasetVersionSort] = None,
    ) -> "DatasetVersionConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "sort": {"type": "DatasetVersionSort", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetVersionConnectionFields("versions", arguments=cleared_arguments)

    @classmethod
    def example_count(
        cls, *, dataset_version_id: Optional[Any] = None
    ) -> "DatasetGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "datasetVersionId": {"type": "GlobalID", "value": dataset_version_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetGraphQLField("example_count", arguments=cleared_arguments)

    @classmethod
    def examples(
        cls,
        *,
        dataset_version_id: Optional[Any] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "DatasetExampleConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "datasetVersionId": {"type": "GlobalID", "value": dataset_version_id},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetExampleConnectionFields("examples", arguments=cleared_arguments)

    @classmethod
    def experiment_count(
        cls, *, dataset_version_id: Optional[Any] = None
    ) -> "DatasetGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "datasetVersionId": {"type": "GlobalID", "value": dataset_version_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetGraphQLField("experiment_count", arguments=cleared_arguments)

    @classmethod
    def experiments(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "ExperimentConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ExperimentConnectionFields("experiments", arguments=cleared_arguments)

    @classmethod
    def experiment_annotation_summaries(cls) -> "ExperimentAnnotationSummaryFields":
        return ExperimentAnnotationSummaryFields("experiment_annotation_summaries")

    last_updated_at: "DatasetGraphQLField" = DatasetGraphQLField("lastUpdatedAt")

    def fields(
        self,
        *subfields: Union[
            DatasetGraphQLField,
            "DatasetExampleConnectionFields",
            "DatasetVersionConnectionFields",
            "ExperimentAnnotationSummaryFields",
            "ExperimentConnectionFields",
        ],
    ) -> "DatasetFields":
        """Subfields should come from the DatasetFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetFields":
        self._alias = alias
        return self


class DatasetConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "DatasetEdgeFields":
        return DatasetEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            DatasetConnectionGraphQLField, "DatasetEdgeFields", "PageInfoFields"
        ],
    ) -> "DatasetConnectionFields":
        """Subfields should come from the DatasetConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetConnectionFields":
        self._alias = alias
        return self


class DatasetEdgeFields(GraphQLField):
    cursor: "DatasetEdgeGraphQLField" = DatasetEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "DatasetFields":
        return DatasetFields("node")

    def fields(
        self, *subfields: Union[DatasetEdgeGraphQLField, "DatasetFields"]
    ) -> "DatasetEdgeFields":
        """Subfields should come from the DatasetEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetEdgeFields":
        self._alias = alias
        return self


class DatasetExampleFields(GraphQLField):
    id: "DatasetExampleGraphQLField" = DatasetExampleGraphQLField("id")
    created_at: "DatasetExampleGraphQLField" = DatasetExampleGraphQLField("createdAt")

    @classmethod
    def revision(
        cls, *, dataset_version_id: Optional[Any] = None
    ) -> "DatasetExampleRevisionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "datasetVersionId": {"type": "GlobalID", "value": dataset_version_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetExampleRevisionFields("revision", arguments=cleared_arguments)

    @classmethod
    def span(cls) -> "SpanFields":
        return SpanFields("span")

    @classmethod
    def experiment_runs(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "ExperimentRunConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ExperimentRunConnectionFields(
            "experiment_runs", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            DatasetExampleGraphQLField,
            "DatasetExampleRevisionFields",
            "ExperimentRunConnectionFields",
            "SpanFields",
        ],
    ) -> "DatasetExampleFields":
        """Subfields should come from the DatasetExampleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetExampleFields":
        self._alias = alias
        return self


class DatasetExampleConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "DatasetExampleEdgeFields":
        return DatasetExampleEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            DatasetExampleConnectionGraphQLField,
            "DatasetExampleEdgeFields",
            "PageInfoFields",
        ],
    ) -> "DatasetExampleConnectionFields":
        """Subfields should come from the DatasetExampleConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetExampleConnectionFields":
        self._alias = alias
        return self


class DatasetExampleEdgeFields(GraphQLField):
    cursor: "DatasetExampleEdgeGraphQLField" = DatasetExampleEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "DatasetExampleFields":
        return DatasetExampleFields("node")

    def fields(
        self, *subfields: Union[DatasetExampleEdgeGraphQLField, "DatasetExampleFields"]
    ) -> "DatasetExampleEdgeFields":
        """Subfields should come from the DatasetExampleEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetExampleEdgeFields":
        self._alias = alias
        return self


class DatasetExampleRevisionFields(GraphQLField):
    input: "DatasetExampleRevisionGraphQLField" = DatasetExampleRevisionGraphQLField(
        "input"
    )
    output: "DatasetExampleRevisionGraphQLField" = DatasetExampleRevisionGraphQLField(
        "output"
    )
    metadata: "DatasetExampleRevisionGraphQLField" = DatasetExampleRevisionGraphQLField(
        "metadata"
    )
    revision_kind: "DatasetExampleRevisionGraphQLField" = (
        DatasetExampleRevisionGraphQLField("revisionKind")
    )
    created_at: "DatasetExampleRevisionGraphQLField" = (
        DatasetExampleRevisionGraphQLField("createdAt")
    )

    def fields(
        self, *subfields: DatasetExampleRevisionGraphQLField
    ) -> "DatasetExampleRevisionFields":
        """Subfields should come from the DatasetExampleRevisionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetExampleRevisionFields":
        self._alias = alias
        return self


class DatasetMutationPayloadFields(GraphQLField):
    @classmethod
    def dataset(cls) -> "DatasetFields":
        return DatasetFields("dataset")

    def fields(
        self, *subfields: Union[DatasetMutationPayloadGraphQLField, "DatasetFields"]
    ) -> "DatasetMutationPayloadFields":
        """Subfields should come from the DatasetMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetMutationPayloadFields":
        self._alias = alias
        return self


class DatasetValuesFields(GraphQLField):
    primary_value: "DatasetValuesGraphQLField" = DatasetValuesGraphQLField(
        "primaryValue"
    )
    reference_value: "DatasetValuesGraphQLField" = DatasetValuesGraphQLField(
        "referenceValue"
    )

    def fields(self, *subfields: DatasetValuesGraphQLField) -> "DatasetValuesFields":
        """Subfields should come from the DatasetValuesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetValuesFields":
        self._alias = alias
        return self


class DatasetVersionFields(GraphQLField):
    id: "DatasetVersionGraphQLField" = DatasetVersionGraphQLField("id")
    description: "DatasetVersionGraphQLField" = DatasetVersionGraphQLField(
        "description"
    )
    metadata: "DatasetVersionGraphQLField" = DatasetVersionGraphQLField("metadata")
    created_at: "DatasetVersionGraphQLField" = DatasetVersionGraphQLField("createdAt")

    def fields(self, *subfields: DatasetVersionGraphQLField) -> "DatasetVersionFields":
        """Subfields should come from the DatasetVersionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetVersionFields":
        self._alias = alias
        return self


class DatasetVersionConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "DatasetVersionEdgeFields":
        return DatasetVersionEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            DatasetVersionConnectionGraphQLField,
            "DatasetVersionEdgeFields",
            "PageInfoFields",
        ],
    ) -> "DatasetVersionConnectionFields":
        """Subfields should come from the DatasetVersionConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetVersionConnectionFields":
        self._alias = alias
        return self


class DatasetVersionEdgeFields(GraphQLField):
    cursor: "DatasetVersionEdgeGraphQLField" = DatasetVersionEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "DatasetVersionFields":
        return DatasetVersionFields("node")

    def fields(
        self, *subfields: Union[DatasetVersionEdgeGraphQLField, "DatasetVersionFields"]
    ) -> "DatasetVersionEdgeFields":
        """Subfields should come from the DatasetVersionEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DatasetVersionEdgeFields":
        self._alias = alias
        return self


class DbTableStatsFields(GraphQLField):
    table_name: "DbTableStatsGraphQLField" = DbTableStatsGraphQLField("tableName")
    num_bytes: "DbTableStatsGraphQLField" = DbTableStatsGraphQLField("numBytes")

    def fields(self, *subfields: DbTableStatsGraphQLField) -> "DbTableStatsFields":
        """Subfields should come from the DbTableStatsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DbTableStatsFields":
        self._alias = alias
        return self


class DeleteApiKeyMutationPayloadFields(GraphQLField):
    api_key_id: "DeleteApiKeyMutationPayloadGraphQLField" = (
        DeleteApiKeyMutationPayloadGraphQLField("apiKeyId")
    )

    @classmethod
    def query(cls) -> "QueryFields":
        return QueryFields("query")

    def fields(
        self, *subfields: Union[DeleteApiKeyMutationPayloadGraphQLField, "QueryFields"]
    ) -> "DeleteApiKeyMutationPayloadFields":
        """Subfields should come from the DeleteApiKeyMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeleteApiKeyMutationPayloadFields":
        self._alias = alias
        return self


class DeletePromptMutationPayloadFields(GraphQLField):
    @classmethod
    def query(cls) -> "QueryFields":
        return QueryFields("query")

    def fields(
        self, *subfields: Union[DeletePromptMutationPayloadGraphQLField, "QueryFields"]
    ) -> "DeletePromptMutationPayloadFields":
        """Subfields should come from the DeletePromptMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DeletePromptMutationPayloadFields":
        self._alias = alias
        return self


class DimensionFields(GraphQLField):
    id: "DimensionGraphQLField" = DimensionGraphQLField("id")
    name: "DimensionGraphQLField" = DimensionGraphQLField("name")
    type: "DimensionGraphQLField" = DimensionGraphQLField("type")
    data_type: "DimensionGraphQLField" = DimensionGraphQLField("dataType")
    shape: "DimensionGraphQLField" = DimensionGraphQLField("shape")

    @classmethod
    def drift_metric(
        cls, metric: ScalarDriftMetric, *, time_range: Optional[TimeRange] = None
    ) -> "DimensionGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "ScalarDriftMetric!", "value": metric},
            "timeRange": {"type": "TimeRange", "value": time_range},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DimensionGraphQLField("drift_metric", arguments=cleared_arguments)

    @classmethod
    def data_quality_metric(
        cls,
        metric: DataQualityMetric,
        *,
        time_range: Optional[TimeRange] = None,
        inferences_role: Optional[InferencesRole] = None,
    ) -> "DimensionGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "DataQualityMetric!", "value": metric},
            "timeRange": {"type": "TimeRange", "value": time_range},
            "inferencesRole": {"type": "InferencesRole", "value": inferences_role},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DimensionGraphQLField("data_quality_metric", arguments=cleared_arguments)

    categories: "DimensionGraphQLField" = DimensionGraphQLField("categories")

    @classmethod
    def data_quality_time_series(
        cls,
        metric: DataQualityMetric,
        time_range: TimeRange,
        granularity: Granularity,
        *,
        inferences_role: Optional[InferencesRole] = None,
    ) -> "DataQualityTimeSeriesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "DataQualityMetric!", "value": metric},
            "timeRange": {"type": "TimeRange!", "value": time_range},
            "granularity": {"type": "Granularity!", "value": granularity},
            "inferencesRole": {"type": "InferencesRole", "value": inferences_role},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DataQualityTimeSeriesFields(
            "data_quality_time_series", arguments=cleared_arguments
        )

    @classmethod
    def drift_time_series(
        cls, metric: ScalarDriftMetric, time_range: TimeRange, granularity: Granularity
    ) -> "DriftTimeSeriesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "ScalarDriftMetric!", "value": metric},
            "timeRange": {"type": "TimeRange!", "value": time_range},
            "granularity": {"type": "Granularity!", "value": granularity},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DriftTimeSeriesFields("drift_time_series", arguments=cleared_arguments)

    @classmethod
    def segments_comparison(
        cls, *, primary_time_range: Optional[TimeRange] = None
    ) -> "SegmentsFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "primaryTimeRange": {"type": "TimeRange", "value": primary_time_range}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SegmentsFields("segments_comparison", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            DimensionGraphQLField,
            "DataQualityTimeSeriesFields",
            "DriftTimeSeriesFields",
            "SegmentsFields",
        ],
    ) -> "DimensionFields":
        """Subfields should come from the DimensionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DimensionFields":
        self._alias = alias
        return self


class DimensionConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "DimensionEdgeFields":
        return DimensionEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            DimensionConnectionGraphQLField, "DimensionEdgeFields", "PageInfoFields"
        ],
    ) -> "DimensionConnectionFields":
        """Subfields should come from the DimensionConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DimensionConnectionFields":
        self._alias = alias
        return self


class DimensionEdgeFields(GraphQLField):
    cursor: "DimensionEdgeGraphQLField" = DimensionEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "DimensionFields":
        return DimensionFields("node")

    def fields(
        self, *subfields: Union[DimensionEdgeGraphQLField, "DimensionFields"]
    ) -> "DimensionEdgeFields":
        """Subfields should come from the DimensionEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DimensionEdgeFields":
        self._alias = alias
        return self


class DimensionWithValueFields(GraphQLField):
    @classmethod
    def dimension(cls) -> "DimensionFields":
        return DimensionFields("dimension")

    value: "DimensionWithValueGraphQLField" = DimensionWithValueGraphQLField("value")

    def fields(
        self, *subfields: Union[DimensionWithValueGraphQLField, "DimensionFields"]
    ) -> "DimensionWithValueFields":
        """Subfields should come from the DimensionWithValueFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DimensionWithValueFields":
        self._alias = alias
        return self


class DocumentEvaluationFields(GraphQLField):
    name: "DocumentEvaluationGraphQLField" = DocumentEvaluationGraphQLField("name")
    score: "DocumentEvaluationGraphQLField" = DocumentEvaluationGraphQLField("score")
    label: "DocumentEvaluationGraphQLField" = DocumentEvaluationGraphQLField("label")
    explanation: "DocumentEvaluationGraphQLField" = DocumentEvaluationGraphQLField(
        "explanation"
    )
    document_position: "DocumentEvaluationGraphQLField" = (
        DocumentEvaluationGraphQLField("documentPosition")
    )

    def fields(
        self, *subfields: DocumentEvaluationGraphQLField
    ) -> "DocumentEvaluationFields":
        """Subfields should come from the DocumentEvaluationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DocumentEvaluationFields":
        self._alias = alias
        return self


class DocumentEvaluationSummaryFields(GraphQLField):
    evaluation_name: "DocumentEvaluationSummaryGraphQLField" = (
        DocumentEvaluationSummaryGraphQLField("evaluationName")
    )

    @classmethod
    def average_ndcg(
        cls, *, k: Optional[int] = None
    ) -> "DocumentEvaluationSummaryGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {"k": {"type": "Int", "value": k}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DocumentEvaluationSummaryGraphQLField(
            "average_ndcg", arguments=cleared_arguments
        )

    @classmethod
    def count_ndcg(
        cls, *, k: Optional[int] = None
    ) -> "DocumentEvaluationSummaryGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {"k": {"type": "Int", "value": k}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DocumentEvaluationSummaryGraphQLField(
            "count_ndcg", arguments=cleared_arguments
        )

    @classmethod
    def average_precision(
        cls, *, k: Optional[int] = None
    ) -> "DocumentEvaluationSummaryGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {"k": {"type": "Int", "value": k}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DocumentEvaluationSummaryGraphQLField(
            "average_precision", arguments=cleared_arguments
        )

    @classmethod
    def count_precision(
        cls, *, k: Optional[int] = None
    ) -> "DocumentEvaluationSummaryGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {"k": {"type": "Int", "value": k}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DocumentEvaluationSummaryGraphQLField(
            "count_precision", arguments=cleared_arguments
        )

    mean_reciprocal_rank: "DocumentEvaluationSummaryGraphQLField" = (
        DocumentEvaluationSummaryGraphQLField("meanReciprocalRank")
    )
    count_reciprocal_rank: "DocumentEvaluationSummaryGraphQLField" = (
        DocumentEvaluationSummaryGraphQLField("countReciprocalRank")
    )
    hit_rate: "DocumentEvaluationSummaryGraphQLField" = (
        DocumentEvaluationSummaryGraphQLField("hitRate")
    )
    count_hit: "DocumentEvaluationSummaryGraphQLField" = (
        DocumentEvaluationSummaryGraphQLField("countHit")
    )

    def fields(
        self, *subfields: DocumentEvaluationSummaryGraphQLField
    ) -> "DocumentEvaluationSummaryFields":
        """Subfields should come from the DocumentEvaluationSummaryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DocumentEvaluationSummaryFields":
        self._alias = alias
        return self


class DocumentRetrievalMetricsFields(GraphQLField):
    evaluation_name: "DocumentRetrievalMetricsGraphQLField" = (
        DocumentRetrievalMetricsGraphQLField("evaluationName")
    )

    @classmethod
    def ndcg(cls, *, k: Optional[int] = None) -> "DocumentRetrievalMetricsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {"k": {"type": "Int", "value": k}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DocumentRetrievalMetricsGraphQLField("ndcg", arguments=cleared_arguments)

    @classmethod
    def precision(
        cls, *, k: Optional[int] = None
    ) -> "DocumentRetrievalMetricsGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {"k": {"type": "Int", "value": k}}
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DocumentRetrievalMetricsGraphQLField(
            "precision", arguments=cleared_arguments
        )

    reciprocal_rank: "DocumentRetrievalMetricsGraphQLField" = (
        DocumentRetrievalMetricsGraphQLField("reciprocalRank")
    )
    hit: "DocumentRetrievalMetricsGraphQLField" = DocumentRetrievalMetricsGraphQLField(
        "hit"
    )

    def fields(
        self, *subfields: DocumentRetrievalMetricsGraphQLField
    ) -> "DocumentRetrievalMetricsFields":
        """Subfields should come from the DocumentRetrievalMetricsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DocumentRetrievalMetricsFields":
        self._alias = alias
        return self


class DriftTimeSeriesFields(GraphQLField):
    @classmethod
    def data(cls) -> "TimeSeriesDataPointFields":
        return TimeSeriesDataPointFields("data")

    def fields(
        self,
        *subfields: Union[DriftTimeSeriesGraphQLField, "TimeSeriesDataPointFields"],
    ) -> "DriftTimeSeriesFields":
        """Subfields should come from the DriftTimeSeriesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "DriftTimeSeriesFields":
        self._alias = alias
        return self


class EmbeddingDimensionFields(GraphQLField):
    id: "EmbeddingDimensionGraphQLField" = EmbeddingDimensionGraphQLField("id")
    name: "EmbeddingDimensionGraphQLField" = EmbeddingDimensionGraphQLField("name")

    @classmethod
    def drift_metric(
        cls, metric: VectorDriftMetric, *, time_range: Optional[TimeRange] = None
    ) -> "EmbeddingDimensionGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "VectorDriftMetric!", "value": metric},
            "timeRange": {"type": "TimeRange", "value": time_range},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EmbeddingDimensionGraphQLField(
            "drift_metric", arguments=cleared_arguments
        )

    @classmethod
    def retrieval_metric(
        cls, metric: VectorDriftMetric, *, time_range: Optional[TimeRange] = None
    ) -> "EmbeddingDimensionGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "VectorDriftMetric!", "value": metric},
            "timeRange": {"type": "TimeRange", "value": time_range},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EmbeddingDimensionGraphQLField(
            "retrieval_metric", arguments=cleared_arguments
        )

    @classmethod
    def data_quality_time_series(
        cls,
        metric: DataQualityMetric,
        time_range: TimeRange,
        granularity: Granularity,
        *,
        inferences_role: Optional[InferencesRole] = None,
    ) -> "DataQualityTimeSeriesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "DataQualityMetric!", "value": metric},
            "timeRange": {"type": "TimeRange!", "value": time_range},
            "granularity": {"type": "Granularity!", "value": granularity},
            "inferencesRole": {"type": "InferencesRole", "value": inferences_role},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DataQualityTimeSeriesFields(
            "data_quality_time_series", arguments=cleared_arguments
        )

    @classmethod
    def drift_time_series(
        cls, metric: VectorDriftMetric, time_range: TimeRange, granularity: Granularity
    ) -> "DriftTimeSeriesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "VectorDriftMetric!", "value": metric},
            "timeRange": {"type": "TimeRange!", "value": time_range},
            "granularity": {"type": "Granularity!", "value": granularity},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DriftTimeSeriesFields("drift_time_series", arguments=cleared_arguments)

    @classmethod
    def retrieval_metric_time_series(
        cls, metric: VectorDriftMetric, time_range: TimeRange, granularity: Granularity
    ) -> "DriftTimeSeriesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "VectorDriftMetric!", "value": metric},
            "timeRange": {"type": "TimeRange!", "value": time_range},
            "granularity": {"type": "Granularity!", "value": granularity},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DriftTimeSeriesFields(
            "retrieval_metric_time_series", arguments=cleared_arguments
        )

    @classmethod
    def umap_points(
        cls,
        time_range: TimeRange,
        min_dist: float,
        n_neighbors: int,
        n_samples: int,
        min_cluster_size: int,
        cluster_min_samples: int,
        cluster_selection_epsilon: float,
        *,
        n_components: Optional[int] = None,
    ) -> "UMAPPointsFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "timeRange": {"type": "TimeRange!", "value": time_range},
            "nComponents": {"type": "Int", "value": n_components},
            "minDist": {"type": "Float!", "value": min_dist},
            "nNeighbors": {"type": "Int!", "value": n_neighbors},
            "nSamples": {"type": "Int!", "value": n_samples},
            "minClusterSize": {"type": "Int!", "value": min_cluster_size},
            "clusterMinSamples": {"type": "Int!", "value": cluster_min_samples},
            "clusterSelectionEpsilon": {
                "type": "Float!",
                "value": cluster_selection_epsilon,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UMAPPointsFields("umap_points", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            EmbeddingDimensionGraphQLField,
            "DataQualityTimeSeriesFields",
            "DriftTimeSeriesFields",
            "UMAPPointsFields",
        ],
    ) -> "EmbeddingDimensionFields":
        """Subfields should come from the EmbeddingDimensionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EmbeddingDimensionFields":
        self._alias = alias
        return self


class EmbeddingDimensionConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "EmbeddingDimensionEdgeFields":
        return EmbeddingDimensionEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            EmbeddingDimensionConnectionGraphQLField,
            "EmbeddingDimensionEdgeFields",
            "PageInfoFields",
        ],
    ) -> "EmbeddingDimensionConnectionFields":
        """Subfields should come from the EmbeddingDimensionConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EmbeddingDimensionConnectionFields":
        self._alias = alias
        return self


class EmbeddingDimensionEdgeFields(GraphQLField):
    cursor: "EmbeddingDimensionEdgeGraphQLField" = EmbeddingDimensionEdgeGraphQLField(
        "cursor"
    )

    @classmethod
    def node(cls) -> "EmbeddingDimensionFields":
        return EmbeddingDimensionFields("node")

    def fields(
        self,
        *subfields: Union[
            EmbeddingDimensionEdgeGraphQLField, "EmbeddingDimensionFields"
        ],
    ) -> "EmbeddingDimensionEdgeFields":
        """Subfields should come from the EmbeddingDimensionEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EmbeddingDimensionEdgeFields":
        self._alias = alias
        return self


class EmbeddingMetadataFields(GraphQLField):
    prediction_id: "EmbeddingMetadataGraphQLField" = EmbeddingMetadataGraphQLField(
        "predictionId"
    )
    raw_data: "EmbeddingMetadataGraphQLField" = EmbeddingMetadataGraphQLField("rawData")
    link_to_data: "EmbeddingMetadataGraphQLField" = EmbeddingMetadataGraphQLField(
        "linkToData"
    )

    def fields(
        self, *subfields: EmbeddingMetadataGraphQLField
    ) -> "EmbeddingMetadataFields":
        """Subfields should come from the EmbeddingMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EmbeddingMetadataFields":
        self._alias = alias
        return self


class EventFields(GraphQLField):
    id: "EventGraphQLField" = EventGraphQLField("id")

    @classmethod
    def event_metadata(cls) -> "EventMetadataFields":
        return EventMetadataFields("event_metadata")

    @classmethod
    def dimensions(cls) -> "DimensionWithValueFields":
        return DimensionWithValueFields("dimensions")

    @classmethod
    def prompt_and_response(cls) -> "PromptResponseFields":
        return PromptResponseFields("prompt_and_response")

    document_text: "EventGraphQLField" = EventGraphQLField("documentText")

    def fields(
        self,
        *subfields: Union[
            EventGraphQLField,
            "DimensionWithValueFields",
            "EventMetadataFields",
            "PromptResponseFields",
        ],
    ) -> "EventFields":
        """Subfields should come from the EventFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EventFields":
        self._alias = alias
        return self


class EventMetadataFields(GraphQLField):
    prediction_id: "EventMetadataGraphQLField" = EventMetadataGraphQLField(
        "predictionId"
    )
    prediction_score: "EventMetadataGraphQLField" = EventMetadataGraphQLField(
        "predictionScore"
    )
    prediction_label: "EventMetadataGraphQLField" = EventMetadataGraphQLField(
        "predictionLabel"
    )
    actual_score: "EventMetadataGraphQLField" = EventMetadataGraphQLField("actualScore")
    actual_label: "EventMetadataGraphQLField" = EventMetadataGraphQLField("actualLabel")

    def fields(self, *subfields: EventMetadataGraphQLField) -> "EventMetadataFields":
        """Subfields should come from the EventMetadataFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "EventMetadataFields":
        self._alias = alias
        return self


class ExampleRevisionInterface(GraphQLField):
    input: "ExampleRevisionGraphQLField" = ExampleRevisionGraphQLField("input")
    output: "ExampleRevisionGraphQLField" = ExampleRevisionGraphQLField("output")
    metadata: "ExampleRevisionGraphQLField" = ExampleRevisionGraphQLField("metadata")

    def fields(
        self, *subfields: ExampleRevisionGraphQLField
    ) -> "ExampleRevisionInterface":
        """Subfields should come from the ExampleRevisionInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExampleRevisionInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "ExampleRevisionInterface":
        self._inline_fragments[type_name] = subfields
        return self


class ExperimentFields(GraphQLField):
    id: "ExperimentGraphQLField" = ExperimentGraphQLField("id")
    name: "ExperimentGraphQLField" = ExperimentGraphQLField("name")
    project_name: "ExperimentGraphQLField" = ExperimentGraphQLField("projectName")
    description: "ExperimentGraphQLField" = ExperimentGraphQLField("description")
    metadata: "ExperimentGraphQLField" = ExperimentGraphQLField("metadata")
    created_at: "ExperimentGraphQLField" = ExperimentGraphQLField("createdAt")
    updated_at: "ExperimentGraphQLField" = ExperimentGraphQLField("updatedAt")
    sequence_number: "ExperimentGraphQLField" = ExperimentGraphQLField("sequenceNumber")

    @classmethod
    def runs(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "ExperimentRunConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ExperimentRunConnectionFields("runs", arguments=cleared_arguments)

    run_count: "ExperimentGraphQLField" = ExperimentGraphQLField("runCount")

    @classmethod
    def annotation_summaries(cls) -> "ExperimentAnnotationSummaryFields":
        return ExperimentAnnotationSummaryFields("annotation_summaries")

    error_rate: "ExperimentGraphQLField" = ExperimentGraphQLField("errorRate")
    average_run_latency_ms: "ExperimentGraphQLField" = ExperimentGraphQLField(
        "averageRunLatencyMs"
    )

    @classmethod
    def project(cls) -> "ProjectFields":
        return ProjectFields("project")

    last_updated_at: "ExperimentGraphQLField" = ExperimentGraphQLField("lastUpdatedAt")

    def fields(
        self,
        *subfields: Union[
            ExperimentGraphQLField,
            "ExperimentAnnotationSummaryFields",
            "ExperimentRunConnectionFields",
            "ProjectFields",
        ],
    ) -> "ExperimentFields":
        """Subfields should come from the ExperimentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentFields":
        self._alias = alias
        return self


class ExperimentAnnotationSummaryFields(GraphQLField):
    annotation_name: "ExperimentAnnotationSummaryGraphQLField" = (
        ExperimentAnnotationSummaryGraphQLField("annotationName")
    )
    min_score: "ExperimentAnnotationSummaryGraphQLField" = (
        ExperimentAnnotationSummaryGraphQLField("minScore")
    )
    max_score: "ExperimentAnnotationSummaryGraphQLField" = (
        ExperimentAnnotationSummaryGraphQLField("maxScore")
    )
    mean_score: "ExperimentAnnotationSummaryGraphQLField" = (
        ExperimentAnnotationSummaryGraphQLField("meanScore")
    )
    count: "ExperimentAnnotationSummaryGraphQLField" = (
        ExperimentAnnotationSummaryGraphQLField("count")
    )
    error_count: "ExperimentAnnotationSummaryGraphQLField" = (
        ExperimentAnnotationSummaryGraphQLField("errorCount")
    )

    def fields(
        self, *subfields: ExperimentAnnotationSummaryGraphQLField
    ) -> "ExperimentAnnotationSummaryFields":
        """Subfields should come from the ExperimentAnnotationSummaryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentAnnotationSummaryFields":
        self._alias = alias
        return self


class ExperimentComparisonFields(GraphQLField):
    @classmethod
    def example(cls) -> "DatasetExampleFields":
        return DatasetExampleFields("example")

    @classmethod
    def run_comparison_items(cls) -> "RunComparisonItemFields":
        return RunComparisonItemFields("run_comparison_items")

    def fields(
        self,
        *subfields: Union[
            ExperimentComparisonGraphQLField,
            "DatasetExampleFields",
            "RunComparisonItemFields",
        ],
    ) -> "ExperimentComparisonFields":
        """Subfields should come from the ExperimentComparisonFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentComparisonFields":
        self._alias = alias
        return self


class ExperimentConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "ExperimentEdgeFields":
        return ExperimentEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            ExperimentConnectionGraphQLField, "ExperimentEdgeFields", "PageInfoFields"
        ],
    ) -> "ExperimentConnectionFields":
        """Subfields should come from the ExperimentConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentConnectionFields":
        self._alias = alias
        return self


class ExperimentEdgeFields(GraphQLField):
    cursor: "ExperimentEdgeGraphQLField" = ExperimentEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "ExperimentFields":
        return ExperimentFields("node")

    def fields(
        self, *subfields: Union[ExperimentEdgeGraphQLField, "ExperimentFields"]
    ) -> "ExperimentEdgeFields":
        """Subfields should come from the ExperimentEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentEdgeFields":
        self._alias = alias
        return self


class ExperimentMutationPayloadFields(GraphQLField):
    @classmethod
    def experiments(cls) -> "ExperimentFields":
        return ExperimentFields("experiments")

    def fields(
        self,
        *subfields: Union[ExperimentMutationPayloadGraphQLField, "ExperimentFields"],
    ) -> "ExperimentMutationPayloadFields":
        """Subfields should come from the ExperimentMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentMutationPayloadFields":
        self._alias = alias
        return self


class ExperimentRunFields(GraphQLField):
    id: "ExperimentRunGraphQLField" = ExperimentRunGraphQLField("id")
    experiment_id: "ExperimentRunGraphQLField" = ExperimentRunGraphQLField(
        "experimentId"
    )
    trace_id: "ExperimentRunGraphQLField" = ExperimentRunGraphQLField("traceId")
    output: "ExperimentRunGraphQLField" = ExperimentRunGraphQLField("output")
    start_time: "ExperimentRunGraphQLField" = ExperimentRunGraphQLField("startTime")
    end_time: "ExperimentRunGraphQLField" = ExperimentRunGraphQLField("endTime")
    error: "ExperimentRunGraphQLField" = ExperimentRunGraphQLField("error")

    @classmethod
    def annotations(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "ExperimentRunAnnotationConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ExperimentRunAnnotationConnectionFields(
            "annotations", arguments=cleared_arguments
        )

    @classmethod
    def trace(cls) -> "TraceFields":
        return TraceFields("trace")

    @classmethod
    def example(cls) -> "DatasetExampleFields":
        return DatasetExampleFields("example")

    def fields(
        self,
        *subfields: Union[
            ExperimentRunGraphQLField,
            "DatasetExampleFields",
            "ExperimentRunAnnotationConnectionFields",
            "TraceFields",
        ],
    ) -> "ExperimentRunFields":
        """Subfields should come from the ExperimentRunFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentRunFields":
        self._alias = alias
        return self


class ExperimentRunAnnotationFields(GraphQLField):
    id: "ExperimentRunAnnotationGraphQLField" = ExperimentRunAnnotationGraphQLField(
        "id"
    )
    name: "ExperimentRunAnnotationGraphQLField" = ExperimentRunAnnotationGraphQLField(
        "name"
    )
    annotator_kind: "ExperimentRunAnnotationGraphQLField" = (
        ExperimentRunAnnotationGraphQLField("annotatorKind")
    )
    label: "ExperimentRunAnnotationGraphQLField" = ExperimentRunAnnotationGraphQLField(
        "label"
    )
    score: "ExperimentRunAnnotationGraphQLField" = ExperimentRunAnnotationGraphQLField(
        "score"
    )
    explanation: "ExperimentRunAnnotationGraphQLField" = (
        ExperimentRunAnnotationGraphQLField("explanation")
    )
    error: "ExperimentRunAnnotationGraphQLField" = ExperimentRunAnnotationGraphQLField(
        "error"
    )
    metadata: "ExperimentRunAnnotationGraphQLField" = (
        ExperimentRunAnnotationGraphQLField("metadata")
    )
    start_time: "ExperimentRunAnnotationGraphQLField" = (
        ExperimentRunAnnotationGraphQLField("startTime")
    )
    end_time: "ExperimentRunAnnotationGraphQLField" = (
        ExperimentRunAnnotationGraphQLField("endTime")
    )
    trace_id: "ExperimentRunAnnotationGraphQLField" = (
        ExperimentRunAnnotationGraphQLField("traceId")
    )

    @classmethod
    def trace(cls) -> "TraceFields":
        return TraceFields("trace")

    def fields(
        self, *subfields: Union[ExperimentRunAnnotationGraphQLField, "TraceFields"]
    ) -> "ExperimentRunAnnotationFields":
        """Subfields should come from the ExperimentRunAnnotationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentRunAnnotationFields":
        self._alias = alias
        return self


class ExperimentRunAnnotationConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "ExperimentRunAnnotationEdgeFields":
        return ExperimentRunAnnotationEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            ExperimentRunAnnotationConnectionGraphQLField,
            "ExperimentRunAnnotationEdgeFields",
            "PageInfoFields",
        ],
    ) -> "ExperimentRunAnnotationConnectionFields":
        """Subfields should come from the ExperimentRunAnnotationConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentRunAnnotationConnectionFields":
        self._alias = alias
        return self


class ExperimentRunAnnotationEdgeFields(GraphQLField):
    cursor: "ExperimentRunAnnotationEdgeGraphQLField" = (
        ExperimentRunAnnotationEdgeGraphQLField("cursor")
    )

    @classmethod
    def node(cls) -> "ExperimentRunAnnotationFields":
        return ExperimentRunAnnotationFields("node")

    def fields(
        self,
        *subfields: Union[
            ExperimentRunAnnotationEdgeGraphQLField, "ExperimentRunAnnotationFields"
        ],
    ) -> "ExperimentRunAnnotationEdgeFields":
        """Subfields should come from the ExperimentRunAnnotationEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentRunAnnotationEdgeFields":
        self._alias = alias
        return self


class ExperimentRunConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "ExperimentRunEdgeFields":
        return ExperimentRunEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            ExperimentRunConnectionGraphQLField,
            "ExperimentRunEdgeFields",
            "PageInfoFields",
        ],
    ) -> "ExperimentRunConnectionFields":
        """Subfields should come from the ExperimentRunConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentRunConnectionFields":
        self._alias = alias
        return self


class ExperimentRunEdgeFields(GraphQLField):
    cursor: "ExperimentRunEdgeGraphQLField" = ExperimentRunEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "ExperimentRunFields":
        return ExperimentRunFields("node")

    def fields(
        self, *subfields: Union[ExperimentRunEdgeGraphQLField, "ExperimentRunFields"]
    ) -> "ExperimentRunEdgeFields":
        """Subfields should come from the ExperimentRunEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExperimentRunEdgeFields":
        self._alias = alias
        return self


class ExportedFileFields(GraphQLField):
    file_name: "ExportedFileGraphQLField" = ExportedFileGraphQLField("fileName")

    def fields(self, *subfields: ExportedFileGraphQLField) -> "ExportedFileFields":
        """Subfields should come from the ExportedFileFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ExportedFileFields":
        self._alias = alias
        return self


class FloatInvocationParameterFields(GraphQLField):
    invocation_name: "FloatInvocationParameterGraphQLField" = (
        FloatInvocationParameterGraphQLField("invocationName")
    )
    canonical_name: "FloatInvocationParameterGraphQLField" = (
        FloatInvocationParameterGraphQLField("canonicalName")
    )
    label: "FloatInvocationParameterGraphQLField" = (
        FloatInvocationParameterGraphQLField("label")
    )
    required: "FloatInvocationParameterGraphQLField" = (
        FloatInvocationParameterGraphQLField("required")
    )
    invocation_input_field: "FloatInvocationParameterGraphQLField" = (
        FloatInvocationParameterGraphQLField("invocationInputField")
    )
    default_value: "FloatInvocationParameterGraphQLField" = (
        FloatInvocationParameterGraphQLField("defaultValue")
    )

    def fields(
        self, *subfields: FloatInvocationParameterGraphQLField
    ) -> "FloatInvocationParameterFields":
        """Subfields should come from the FloatInvocationParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FloatInvocationParameterFields":
        self._alias = alias
        return self


class FunctionalityFields(GraphQLField):
    model_inferences: "FunctionalityGraphQLField" = FunctionalityGraphQLField(
        "modelInferences"
    )
    tracing: "FunctionalityGraphQLField" = FunctionalityGraphQLField("tracing")

    def fields(self, *subfields: FunctionalityGraphQLField) -> "FunctionalityFields":
        """Subfields should come from the FunctionalityFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "FunctionalityFields":
        self._alias = alias
        return self


class GenerativeModelFields(GraphQLField):
    name: "GenerativeModelGraphQLField" = GenerativeModelGraphQLField("name")
    provider_key: "GenerativeModelGraphQLField" = GenerativeModelGraphQLField(
        "providerKey"
    )

    def fields(
        self, *subfields: GenerativeModelGraphQLField
    ) -> "GenerativeModelFields":
        """Subfields should come from the GenerativeModelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GenerativeModelFields":
        self._alias = alias
        return self


class GenerativeProviderFields(GraphQLField):
    name: "GenerativeProviderGraphQLField" = GenerativeProviderGraphQLField("name")
    key: "GenerativeProviderGraphQLField" = GenerativeProviderGraphQLField("key")
    dependencies: "GenerativeProviderGraphQLField" = GenerativeProviderGraphQLField(
        "dependencies"
    )
    dependencies_installed: "GenerativeProviderGraphQLField" = (
        GenerativeProviderGraphQLField("dependenciesInstalled")
    )
    api_key_env_var: "GenerativeProviderGraphQLField" = GenerativeProviderGraphQLField(
        "apiKeyEnvVar"
    )
    api_key_set: "GenerativeProviderGraphQLField" = GenerativeProviderGraphQLField(
        "apiKeySet"
    )

    def fields(
        self, *subfields: GenerativeProviderGraphQLField
    ) -> "GenerativeProviderFields":
        """Subfields should come from the GenerativeProviderFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "GenerativeProviderFields":
        self._alias = alias
        return self


class InferencesFields(GraphQLField):
    start_time: "InferencesGraphQLField" = InferencesGraphQLField("startTime")
    end_time: "InferencesGraphQLField" = InferencesGraphQLField("endTime")
    record_count: "InferencesGraphQLField" = InferencesGraphQLField("recordCount")
    name: "InferencesGraphQLField" = InferencesGraphQLField("name")

    @classmethod
    def events(
        cls, event_ids: str, *, dimensions: Optional[DimensionInput] = None
    ) -> "EventFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "eventIds": {"type": "ID!", "value": event_ids},
            "dimensions": {"type": "DimensionInput", "value": dimensions},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EventFields("events", arguments=cleared_arguments)

    def fields(
        self, *subfields: Union[InferencesGraphQLField, "EventFields"]
    ) -> "InferencesFields":
        """Subfields should come from the InferencesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InferencesFields":
        self._alias = alias
        return self


class IntInvocationParameterFields(GraphQLField):
    invocation_name: "IntInvocationParameterGraphQLField" = (
        IntInvocationParameterGraphQLField("invocationName")
    )
    canonical_name: "IntInvocationParameterGraphQLField" = (
        IntInvocationParameterGraphQLField("canonicalName")
    )
    label: "IntInvocationParameterGraphQLField" = IntInvocationParameterGraphQLField(
        "label"
    )
    required: "IntInvocationParameterGraphQLField" = IntInvocationParameterGraphQLField(
        "required"
    )
    invocation_input_field: "IntInvocationParameterGraphQLField" = (
        IntInvocationParameterGraphQLField("invocationInputField")
    )
    default_value: "IntInvocationParameterGraphQLField" = (
        IntInvocationParameterGraphQLField("defaultValue")
    )

    def fields(
        self, *subfields: IntInvocationParameterGraphQLField
    ) -> "IntInvocationParameterFields":
        """Subfields should come from the IntInvocationParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "IntInvocationParameterFields":
        self._alias = alias
        return self


class IntervalBinFields(GraphQLField):
    @classmethod
    def range(cls) -> "NumericRangeFields":
        return NumericRangeFields("range")

    def fields(
        self, *subfields: Union[IntervalBinGraphQLField, "NumericRangeFields"]
    ) -> "IntervalBinFields":
        """Subfields should come from the IntervalBinFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "IntervalBinFields":
        self._alias = alias
        return self


class InvocationParameterBaseInterface(GraphQLField):
    invocation_name: "InvocationParameterBaseGraphQLField" = (
        InvocationParameterBaseGraphQLField("invocationName")
    )
    canonical_name: "InvocationParameterBaseGraphQLField" = (
        InvocationParameterBaseGraphQLField("canonicalName")
    )
    label: "InvocationParameterBaseGraphQLField" = InvocationParameterBaseGraphQLField(
        "label"
    )
    required: "InvocationParameterBaseGraphQLField" = (
        InvocationParameterBaseGraphQLField("required")
    )

    def fields(
        self, *subfields: InvocationParameterBaseGraphQLField
    ) -> "InvocationParameterBaseInterface":
        """Subfields should come from the InvocationParameterBaseInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "InvocationParameterBaseInterface":
        self._alias = alias
        return self

    def on(
        self, type_name: str, *subfields: GraphQLField
    ) -> "InvocationParameterBaseInterface":
        self._inline_fragments[type_name] = subfields
        return self


class JSONInvocationParameterFields(GraphQLField):
    invocation_name: "JSONInvocationParameterGraphQLField" = (
        JSONInvocationParameterGraphQLField("invocationName")
    )
    canonical_name: "JSONInvocationParameterGraphQLField" = (
        JSONInvocationParameterGraphQLField("canonicalName")
    )
    label: "JSONInvocationParameterGraphQLField" = JSONInvocationParameterGraphQLField(
        "label"
    )
    required: "JSONInvocationParameterGraphQLField" = (
        JSONInvocationParameterGraphQLField("required")
    )
    invocation_input_field: "JSONInvocationParameterGraphQLField" = (
        JSONInvocationParameterGraphQLField("invocationInputField")
    )
    default_value: "JSONInvocationParameterGraphQLField" = (
        JSONInvocationParameterGraphQLField("defaultValue")
    )

    def fields(
        self, *subfields: JSONInvocationParameterGraphQLField
    ) -> "JSONInvocationParameterFields":
        """Subfields should come from the JSONInvocationParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "JSONInvocationParameterFields":
        self._alias = alias
        return self


class LabelFractionFields(GraphQLField):
    label: "LabelFractionGraphQLField" = LabelFractionGraphQLField("label")
    fraction: "LabelFractionGraphQLField" = LabelFractionGraphQLField("fraction")

    def fields(self, *subfields: LabelFractionGraphQLField) -> "LabelFractionFields":
        """Subfields should come from the LabelFractionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "LabelFractionFields":
        self._alias = alias
        return self


class MissingValueBinFields(GraphQLField):
    name: "MissingValueBinGraphQLField" = MissingValueBinGraphQLField("name")

    def fields(
        self, *subfields: MissingValueBinGraphQLField
    ) -> "MissingValueBinFields":
        """Subfields should come from the MissingValueBinFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "MissingValueBinFields":
        self._alias = alias
        return self


class ModelFields(GraphQLField):
    @classmethod
    def dimensions(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
        include: Optional[DimensionFilter] = None,
        exclude: Optional[DimensionFilter] = None,
    ) -> "DimensionConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "include": {"type": "DimensionFilter", "value": include},
            "exclude": {"type": "DimensionFilter", "value": exclude},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DimensionConnectionFields("dimensions", arguments=cleared_arguments)

    @classmethod
    def primary_inferences(cls) -> "InferencesFields":
        return InferencesFields("primary_inferences")

    @classmethod
    def reference_inferences(cls) -> "InferencesFields":
        return InferencesFields("reference_inferences")

    @classmethod
    def corpus_inferences(cls) -> "InferencesFields":
        return InferencesFields("corpus_inferences")

    @classmethod
    def embedding_dimensions(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "EmbeddingDimensionConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return EmbeddingDimensionConnectionFields(
            "embedding_dimensions", arguments=cleared_arguments
        )

    @classmethod
    def exported_files(cls) -> "ExportedFileFields":
        return ExportedFileFields("exported_files")

    @classmethod
    def performance_metric(
        cls,
        metric: PerformanceMetricInput,
        *,
        time_range: Optional[TimeRange] = None,
        inferences_role: Optional[InferencesRole] = None,
    ) -> "ModelGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "PerformanceMetricInput!", "value": metric},
            "timeRange": {"type": "TimeRange", "value": time_range},
            "inferencesRole": {"type": "InferencesRole", "value": inferences_role},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ModelGraphQLField("performance_metric", arguments=cleared_arguments)

    @classmethod
    def performance_time_series(
        cls,
        metric: PerformanceMetricInput,
        time_range: TimeRange,
        granularity: Granularity,
        *,
        inferences_role: Optional[InferencesRole] = None,
    ) -> "PerformanceTimeSeriesFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "metric": {"type": "PerformanceMetricInput!", "value": metric},
            "timeRange": {"type": "TimeRange!", "value": time_range},
            "granularity": {"type": "Granularity!", "value": granularity},
            "inferencesRole": {"type": "InferencesRole", "value": inferences_role},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PerformanceTimeSeriesFields(
            "performance_time_series", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            ModelGraphQLField,
            "DimensionConnectionFields",
            "EmbeddingDimensionConnectionFields",
            "ExportedFileFields",
            "InferencesFields",
            "PerformanceTimeSeriesFields",
        ],
    ) -> "ModelFields":
        """Subfields should come from the ModelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ModelFields":
        self._alias = alias
        return self


class NodeInterface(GraphQLField):
    id: "NodeGraphQLField" = NodeGraphQLField("id")

    def fields(self, *subfields: NodeGraphQLField) -> "NodeInterface":
        """Subfields should come from the NodeInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NodeInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "NodeInterface":
        self._inline_fragments[type_name] = subfields
        return self


class NominalBinFields(GraphQLField):
    name: "NominalBinGraphQLField" = NominalBinGraphQLField("name")

    def fields(self, *subfields: NominalBinGraphQLField) -> "NominalBinFields":
        """Subfields should come from the NominalBinFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NominalBinFields":
        self._alias = alias
        return self


class NumericRangeFields(GraphQLField):
    start: "NumericRangeGraphQLField" = NumericRangeGraphQLField("start")
    end: "NumericRangeGraphQLField" = NumericRangeGraphQLField("end")

    def fields(self, *subfields: NumericRangeGraphQLField) -> "NumericRangeFields":
        """Subfields should come from the NumericRangeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "NumericRangeFields":
        self._alias = alias
        return self


class PageInfoFields(GraphQLField):
    has_next_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasNextPage")
    has_previous_page: "PageInfoGraphQLField" = PageInfoGraphQLField("hasPreviousPage")
    start_cursor: "PageInfoGraphQLField" = PageInfoGraphQLField("startCursor")
    end_cursor: "PageInfoGraphQLField" = PageInfoGraphQLField("endCursor")

    def fields(self, *subfields: PageInfoGraphQLField) -> "PageInfoFields":
        """Subfields should come from the PageInfoFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PageInfoFields":
        self._alias = alias
        return self


class PerformanceTimeSeriesFields(GraphQLField):
    @classmethod
    def data(cls) -> "TimeSeriesDataPointFields":
        return TimeSeriesDataPointFields("data")

    def fields(
        self,
        *subfields: Union[
            PerformanceTimeSeriesGraphQLField, "TimeSeriesDataPointFields"
        ],
    ) -> "PerformanceTimeSeriesFields":
        """Subfields should come from the PerformanceTimeSeriesFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PerformanceTimeSeriesFields":
        self._alias = alias
        return self


class Point2DFields(GraphQLField):
    x: "Point2DGraphQLField" = Point2DGraphQLField("x")
    y: "Point2DGraphQLField" = Point2DGraphQLField("y")

    def fields(self, *subfields: Point2DGraphQLField) -> "Point2DFields":
        """Subfields should come from the Point2DFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "Point2DFields":
        self._alias = alias
        return self


class Point3DFields(GraphQLField):
    x: "Point3DGraphQLField" = Point3DGraphQLField("x")
    y: "Point3DGraphQLField" = Point3DGraphQLField("y")
    z: "Point3DGraphQLField" = Point3DGraphQLField("z")

    def fields(self, *subfields: Point3DGraphQLField) -> "Point3DFields":
        """Subfields should come from the Point3DFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "Point3DFields":
        self._alias = alias
        return self


class ProjectFields(GraphQLField):
    id: "ProjectGraphQLField" = ProjectGraphQLField("id")
    name: "ProjectGraphQLField" = ProjectGraphQLField("name")
    gradient_start_color: "ProjectGraphQLField" = ProjectGraphQLField(
        "gradientStartColor"
    )
    gradient_end_color: "ProjectGraphQLField" = ProjectGraphQLField("gradientEndColor")
    start_time: "ProjectGraphQLField" = ProjectGraphQLField("startTime")
    end_time: "ProjectGraphQLField" = ProjectGraphQLField("endTime")

    @classmethod
    def record_count(
        cls,
        *,
        time_range: Optional[TimeRange] = None,
        filter_condition: Optional[str] = None,
    ) -> "ProjectGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "timeRange": {"type": "TimeRange", "value": time_range},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectGraphQLField("record_count", arguments=cleared_arguments)

    @classmethod
    def trace_count(
        cls, *, time_range: Optional[TimeRange] = None
    ) -> "ProjectGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "timeRange": {"type": "TimeRange", "value": time_range}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectGraphQLField("trace_count", arguments=cleared_arguments)

    @classmethod
    def token_count_total(
        cls,
        *,
        time_range: Optional[TimeRange] = None,
        filter_condition: Optional[str] = None,
    ) -> "ProjectGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "timeRange": {"type": "TimeRange", "value": time_range},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectGraphQLField("token_count_total", arguments=cleared_arguments)

    @classmethod
    def token_count_prompt(
        cls,
        *,
        time_range: Optional[TimeRange] = None,
        filter_condition: Optional[str] = None,
    ) -> "ProjectGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "timeRange": {"type": "TimeRange", "value": time_range},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectGraphQLField("token_count_prompt", arguments=cleared_arguments)

    @classmethod
    def token_count_completion(
        cls,
        *,
        time_range: Optional[TimeRange] = None,
        filter_condition: Optional[str] = None,
    ) -> "ProjectGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "timeRange": {"type": "TimeRange", "value": time_range},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectGraphQLField(
            "token_count_completion", arguments=cleared_arguments
        )

    @classmethod
    def latency_ms_quantile(
        cls, probability: float, *, time_range: Optional[TimeRange] = None
    ) -> "ProjectGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "probability": {"type": "Float!", "value": probability},
            "timeRange": {"type": "TimeRange", "value": time_range},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectGraphQLField("latency_ms_quantile", arguments=cleared_arguments)

    @classmethod
    def span_latency_ms_quantile(
        cls,
        probability: float,
        *,
        time_range: Optional[TimeRange] = None,
        filter_condition: Optional[str] = None,
    ) -> "ProjectGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "probability": {"type": "Float!", "value": probability},
            "timeRange": {"type": "TimeRange", "value": time_range},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectGraphQLField(
            "span_latency_ms_quantile", arguments=cleared_arguments
        )

    @classmethod
    def trace(cls, trace_id: str) -> "TraceFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "traceId": {"type": "ID!", "value": trace_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TraceFields("trace", arguments=cleared_arguments)

    @classmethod
    def spans(
        cls,
        *,
        time_range: Optional[TimeRange] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
        sort: Optional[SpanSort] = None,
        root_spans_only: Optional[bool] = None,
        filter_condition: Optional[str] = None,
        orphan_span_as_root_span: Optional[bool] = None,
    ) -> "SpanConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "timeRange": {"type": "TimeRange", "value": time_range},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "sort": {"type": "SpanSort", "value": sort},
            "rootSpansOnly": {"type": "Boolean", "value": root_spans_only},
            "filterCondition": {"type": "String", "value": filter_condition},
            "orphanSpanAsRootSpan": {
                "type": "Boolean",
                "value": orphan_span_as_root_span,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SpanConnectionFields("spans", arguments=cleared_arguments)

    @classmethod
    def sessions(
        cls,
        *,
        time_range: Optional[TimeRange] = None,
        first: Optional[int] = None,
        after: Optional[str] = None,
        sort: Optional[ProjectSessionSort] = None,
        filter_io_substring: Optional[str] = None,
    ) -> "ProjectSessionConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "timeRange": {"type": "TimeRange", "value": time_range},
            "first": {"type": "Int", "value": first},
            "after": {"type": "String", "value": after},
            "sort": {"type": "ProjectSessionSort", "value": sort},
            "filterIoSubstring": {"type": "String", "value": filter_io_substring},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectSessionConnectionFields("sessions", arguments=cleared_arguments)

    trace_annotations_names: "ProjectGraphQLField" = ProjectGraphQLField(
        "traceAnnotationsNames"
    )
    span_annotation_names: "ProjectGraphQLField" = ProjectGraphQLField(
        "spanAnnotationNames"
    )

    @classmethod
    def document_evaluation_names(
        cls, *, span_id: Optional[str] = None
    ) -> "ProjectGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "spanId": {"type": "ID", "value": span_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectGraphQLField(
            "document_evaluation_names", arguments=cleared_arguments
        )

    @classmethod
    def trace_annotation_summary(
        cls, annotation_name: str, *, time_range: Optional[TimeRange] = None
    ) -> "AnnotationSummaryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "annotationName": {"type": "String!", "value": annotation_name},
            "timeRange": {"type": "TimeRange", "value": time_range},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return AnnotationSummaryFields(
            "trace_annotation_summary", arguments=cleared_arguments
        )

    @classmethod
    def span_annotation_summary(
        cls,
        annotation_name: str,
        *,
        time_range: Optional[TimeRange] = None,
        filter_condition: Optional[str] = None,
    ) -> "AnnotationSummaryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "annotationName": {"type": "String!", "value": annotation_name},
            "timeRange": {"type": "TimeRange", "value": time_range},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return AnnotationSummaryFields(
            "span_annotation_summary", arguments=cleared_arguments
        )

    @classmethod
    def document_evaluation_summary(
        cls,
        evaluation_name: str,
        *,
        time_range: Optional[TimeRange] = None,
        filter_condition: Optional[str] = None,
    ) -> "DocumentEvaluationSummaryFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "evaluationName": {"type": "String!", "value": evaluation_name},
            "timeRange": {"type": "TimeRange", "value": time_range},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DocumentEvaluationSummaryFields(
            "document_evaluation_summary", arguments=cleared_arguments
        )

    streaming_last_updated_at: "ProjectGraphQLField" = ProjectGraphQLField(
        "streamingLastUpdatedAt"
    )

    @classmethod
    def validate_span_filter_condition(cls, condition: str) -> "ValidationResultFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "condition": {"type": "String!", "value": condition}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ValidationResultFields(
            "validate_span_filter_condition", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            ProjectGraphQLField,
            "AnnotationSummaryFields",
            "DocumentEvaluationSummaryFields",
            "ProjectSessionConnectionFields",
            "SpanConnectionFields",
            "TraceFields",
            "ValidationResultFields",
        ],
    ) -> "ProjectFields":
        """Subfields should come from the ProjectFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ProjectFields":
        self._alias = alias
        return self


class ProjectConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "ProjectEdgeFields":
        return ProjectEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            ProjectConnectionGraphQLField, "PageInfoFields", "ProjectEdgeFields"
        ],
    ) -> "ProjectConnectionFields":
        """Subfields should come from the ProjectConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ProjectConnectionFields":
        self._alias = alias
        return self


class ProjectEdgeFields(GraphQLField):
    cursor: "ProjectEdgeGraphQLField" = ProjectEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "ProjectFields":
        return ProjectFields("node")

    def fields(
        self, *subfields: Union[ProjectEdgeGraphQLField, "ProjectFields"]
    ) -> "ProjectEdgeFields":
        """Subfields should come from the ProjectEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ProjectEdgeFields":
        self._alias = alias
        return self


class ProjectSessionFields(GraphQLField):
    id: "ProjectSessionGraphQLField" = ProjectSessionGraphQLField("id")
    session_id: "ProjectSessionGraphQLField" = ProjectSessionGraphQLField("sessionId")
    start_time: "ProjectSessionGraphQLField" = ProjectSessionGraphQLField("startTime")
    end_time: "ProjectSessionGraphQLField" = ProjectSessionGraphQLField("endTime")
    project_id: "ProjectSessionGraphQLField" = ProjectSessionGraphQLField("projectId")
    num_traces: "ProjectSessionGraphQLField" = ProjectSessionGraphQLField("numTraces")
    num_traces_with_error: "ProjectSessionGraphQLField" = ProjectSessionGraphQLField(
        "numTracesWithError"
    )

    @classmethod
    def first_input(cls) -> "SpanIOValueFields":
        return SpanIOValueFields("first_input")

    @classmethod
    def last_output(cls) -> "SpanIOValueFields":
        return SpanIOValueFields("last_output")

    @classmethod
    def token_usage(cls) -> "TokenUsageFields":
        return TokenUsageFields("token_usage")

    @classmethod
    def traces(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "TraceConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TraceConnectionFields("traces", arguments=cleared_arguments)

    @classmethod
    def trace_latency_ms_quantile(
        cls, probability: float
    ) -> "ProjectSessionGraphQLField":
        arguments: Dict[str, Dict[str, Any]] = {
            "probability": {"type": "Float!", "value": probability}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectSessionGraphQLField(
            "trace_latency_ms_quantile", arguments=cleared_arguments
        )

    def fields(
        self,
        *subfields: Union[
            ProjectSessionGraphQLField,
            "SpanIOValueFields",
            "TokenUsageFields",
            "TraceConnectionFields",
        ],
    ) -> "ProjectSessionFields":
        """Subfields should come from the ProjectSessionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ProjectSessionFields":
        self._alias = alias
        return self


class ProjectSessionConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "ProjectSessionEdgeFields":
        return ProjectSessionEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            ProjectSessionConnectionGraphQLField,
            "PageInfoFields",
            "ProjectSessionEdgeFields",
        ],
    ) -> "ProjectSessionConnectionFields":
        """Subfields should come from the ProjectSessionConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ProjectSessionConnectionFields":
        self._alias = alias
        return self


class ProjectSessionEdgeFields(GraphQLField):
    cursor: "ProjectSessionEdgeGraphQLField" = ProjectSessionEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "ProjectSessionFields":
        return ProjectSessionFields("node")

    def fields(
        self, *subfields: Union[ProjectSessionEdgeGraphQLField, "ProjectSessionFields"]
    ) -> "ProjectSessionEdgeFields":
        """Subfields should come from the ProjectSessionEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ProjectSessionEdgeFields":
        self._alias = alias
        return self


class PromptFields(GraphQLField):
    id: "PromptGraphQLField" = PromptGraphQLField("id")
    source_prompt_id: "PromptGraphQLField" = PromptGraphQLField("sourcePromptId")
    name: "PromptGraphQLField" = PromptGraphQLField("name")
    description: "PromptGraphQLField" = PromptGraphQLField("description")
    created_at: "PromptGraphQLField" = PromptGraphQLField("createdAt")

    @classmethod
    def version(cls, *, version_id: Optional[Any] = None) -> "PromptVersionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "versionId": {"type": "GlobalID", "value": version_id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PromptVersionFields("version", arguments=cleared_arguments)

    @classmethod
    def version_tags(cls) -> "PromptVersionTagFields":
        return PromptVersionTagFields("version_tags")

    @classmethod
    def prompt_versions(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "PromptVersionConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PromptVersionConnectionFields(
            "prompt_versions", arguments=cleared_arguments
        )

    @classmethod
    def source_prompt(cls) -> "PromptFields":
        return PromptFields("source_prompt")

    def fields(
        self,
        *subfields: Union[
            PromptGraphQLField,
            "PromptFields",
            "PromptVersionConnectionFields",
            "PromptVersionFields",
            "PromptVersionTagFields",
        ],
    ) -> "PromptFields":
        """Subfields should come from the PromptFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptFields":
        self._alias = alias
        return self


class PromptChatTemplateFields(GraphQLField):
    @classmethod
    def messages(cls) -> "PromptMessageFields":
        return PromptMessageFields("messages")

    def fields(
        self, *subfields: Union[PromptChatTemplateGraphQLField, "PromptMessageFields"]
    ) -> "PromptChatTemplateFields":
        """Subfields should come from the PromptChatTemplateFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptChatTemplateFields":
        self._alias = alias
        return self


class PromptConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "PromptEdgeFields":
        return PromptEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            PromptConnectionGraphQLField, "PageInfoFields", "PromptEdgeFields"
        ],
    ) -> "PromptConnectionFields":
        """Subfields should come from the PromptConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptConnectionFields":
        self._alias = alias
        return self


class PromptEdgeFields(GraphQLField):
    cursor: "PromptEdgeGraphQLField" = PromptEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "PromptFields":
        return PromptFields("node")

    def fields(
        self, *subfields: Union[PromptEdgeGraphQLField, "PromptFields"]
    ) -> "PromptEdgeFields":
        """Subfields should come from the PromptEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptEdgeFields":
        self._alias = alias
        return self


class PromptLabelFields(GraphQLField):
    id: "PromptLabelGraphQLField" = PromptLabelGraphQLField("id")
    name: "PromptLabelGraphQLField" = PromptLabelGraphQLField("name")
    description: "PromptLabelGraphQLField" = PromptLabelGraphQLField("description")

    @classmethod
    def prompts(cls) -> "PromptFields":
        return PromptFields("prompts")

    def fields(
        self, *subfields: Union[PromptLabelGraphQLField, "PromptFields"]
    ) -> "PromptLabelFields":
        """Subfields should come from the PromptLabelFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptLabelFields":
        self._alias = alias
        return self


class PromptLabelConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "PromptLabelEdgeFields":
        return PromptLabelEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            PromptLabelConnectionGraphQLField, "PageInfoFields", "PromptLabelEdgeFields"
        ],
    ) -> "PromptLabelConnectionFields":
        """Subfields should come from the PromptLabelConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptLabelConnectionFields":
        self._alias = alias
        return self


class PromptLabelEdgeFields(GraphQLField):
    cursor: "PromptLabelEdgeGraphQLField" = PromptLabelEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "PromptLabelFields":
        return PromptLabelFields("node")

    def fields(
        self, *subfields: Union[PromptLabelEdgeGraphQLField, "PromptLabelFields"]
    ) -> "PromptLabelEdgeFields":
        """Subfields should come from the PromptLabelEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptLabelEdgeFields":
        self._alias = alias
        return self


class PromptLabelMutationPayloadFields(GraphQLField):
    @classmethod
    def prompt_label(cls) -> "PromptLabelFields":
        return PromptLabelFields("prompt_label")

    @classmethod
    def query(cls) -> "QueryFields":
        return QueryFields("query")

    def fields(
        self,
        *subfields: Union[
            PromptLabelMutationPayloadGraphQLField, "PromptLabelFields", "QueryFields"
        ],
    ) -> "PromptLabelMutationPayloadFields":
        """Subfields should come from the PromptLabelMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptLabelMutationPayloadFields":
        self._alias = alias
        return self


class PromptMessageFields(GraphQLField):
    role: "PromptMessageGraphQLField" = PromptMessageGraphQLField("role")
    content: "ContentPartUnion" = ContentPartUnion("content")

    def fields(
        self, *subfields: Union[PromptMessageGraphQLField, "ContentPartUnion"]
    ) -> "PromptMessageFields":
        """Subfields should come from the PromptMessageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptMessageFields":
        self._alias = alias
        return self


class PromptResponseFields(GraphQLField):
    prompt: "PromptResponseGraphQLField" = PromptResponseGraphQLField("prompt")
    response: "PromptResponseGraphQLField" = PromptResponseGraphQLField("response")

    def fields(self, *subfields: PromptResponseGraphQLField) -> "PromptResponseFields":
        """Subfields should come from the PromptResponseFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptResponseFields":
        self._alias = alias
        return self


class PromptStringTemplateFields(GraphQLField):
    template: "PromptStringTemplateGraphQLField" = PromptStringTemplateGraphQLField(
        "template"
    )

    def fields(
        self, *subfields: PromptStringTemplateGraphQLField
    ) -> "PromptStringTemplateFields":
        """Subfields should come from the PromptStringTemplateFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptStringTemplateFields":
        self._alias = alias
        return self


class PromptVersionFields(GraphQLField):
    id: "PromptVersionGraphQLField" = PromptVersionGraphQLField("id")
    description: "PromptVersionGraphQLField" = PromptVersionGraphQLField("description")
    template_type: "PromptVersionGraphQLField" = PromptVersionGraphQLField(
        "templateType"
    )
    template_format: "PromptVersionGraphQLField" = PromptVersionGraphQLField(
        "templateFormat"
    )
    template: "PromptTemplateUnion" = PromptTemplateUnion("template")
    invocation_parameters: "PromptVersionGraphQLField" = PromptVersionGraphQLField(
        "invocationParameters"
    )

    @classmethod
    def tools(cls) -> "ToolDefinitionFields":
        return ToolDefinitionFields("tools")

    @classmethod
    def response_format(cls) -> "ResponseFormatFields":
        return ResponseFormatFields("response_format")

    model_name: "PromptVersionGraphQLField" = PromptVersionGraphQLField("modelName")
    model_provider: "PromptVersionGraphQLField" = PromptVersionGraphQLField(
        "modelProvider"
    )
    metadata: "PromptVersionGraphQLField" = PromptVersionGraphQLField("metadata")
    created_at: "PromptVersionGraphQLField" = PromptVersionGraphQLField("createdAt")

    @classmethod
    def tags(cls) -> "PromptVersionTagFields":
        return PromptVersionTagFields("tags")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    @classmethod
    def previous_version(cls) -> "PromptVersionFields":
        return PromptVersionFields("previous_version")

    sequence_number: "PromptVersionGraphQLField" = PromptVersionGraphQLField(
        "sequenceNumber"
    )

    def fields(
        self,
        *subfields: Union[
            PromptVersionGraphQLField,
            "PromptTemplateUnion",
            "PromptVersionFields",
            "PromptVersionTagFields",
            "ResponseFormatFields",
            "ToolDefinitionFields",
            "UserFields",
        ],
    ) -> "PromptVersionFields":
        """Subfields should come from the PromptVersionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptVersionFields":
        self._alias = alias
        return self


class PromptVersionConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "PromptVersionEdgeFields":
        return PromptVersionEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            PromptVersionConnectionGraphQLField,
            "PageInfoFields",
            "PromptVersionEdgeFields",
        ],
    ) -> "PromptVersionConnectionFields":
        """Subfields should come from the PromptVersionConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptVersionConnectionFields":
        self._alias = alias
        return self


class PromptVersionEdgeFields(GraphQLField):
    cursor: "PromptVersionEdgeGraphQLField" = PromptVersionEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "PromptVersionFields":
        return PromptVersionFields("node")

    def fields(
        self, *subfields: Union[PromptVersionEdgeGraphQLField, "PromptVersionFields"]
    ) -> "PromptVersionEdgeFields":
        """Subfields should come from the PromptVersionEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptVersionEdgeFields":
        self._alias = alias
        return self


class PromptVersionTagFields(GraphQLField):
    id: "PromptVersionTagGraphQLField" = PromptVersionTagGraphQLField("id")
    prompt_version_id: "PromptVersionTagGraphQLField" = PromptVersionTagGraphQLField(
        "promptVersionId"
    )
    name: "PromptVersionTagGraphQLField" = PromptVersionTagGraphQLField("name")
    description: "PromptVersionTagGraphQLField" = PromptVersionTagGraphQLField(
        "description"
    )

    def fields(
        self, *subfields: PromptVersionTagGraphQLField
    ) -> "PromptVersionTagFields":
        """Subfields should come from the PromptVersionTagFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptVersionTagFields":
        self._alias = alias
        return self


class PromptVersionTagMutationPayloadFields(GraphQLField):
    @classmethod
    def prompt_version_tag(cls) -> "PromptVersionTagFields":
        return PromptVersionTagFields("prompt_version_tag")

    @classmethod
    def prompt(cls) -> "PromptFields":
        return PromptFields("prompt")

    @classmethod
    def query(cls) -> "QueryFields":
        return QueryFields("query")

    def fields(
        self,
        *subfields: Union[
            PromptVersionTagMutationPayloadGraphQLField,
            "PromptFields",
            "PromptVersionTagFields",
            "QueryFields",
        ],
    ) -> "PromptVersionTagMutationPayloadFields":
        """Subfields should come from the PromptVersionTagMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "PromptVersionTagMutationPayloadFields":
        self._alias = alias
        return self


class QueryFields(GraphQLField):
    @classmethod
    def model_providers(cls) -> "GenerativeProviderFields":
        return GenerativeProviderFields("model_providers")

    @classmethod
    def models(cls, *, input: Optional[ModelsInput] = None) -> "GenerativeModelFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "ModelsInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GenerativeModelFields("models", arguments=cleared_arguments)

    @classmethod
    def model_invocation_parameters(
        cls, *, input: Optional[ModelsInput] = None
    ) -> "InvocationParameterUnion":
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "ModelsInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return InvocationParameterUnion(
            "model_invocation_parameters", arguments=cleared_arguments
        )

    @classmethod
    def users(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "UserConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserConnectionFields("users", arguments=cleared_arguments)

    @classmethod
    def user_roles(cls) -> "UserRoleFields":
        return UserRoleFields("user_roles")

    @classmethod
    def user_api_keys(cls) -> "UserApiKeyFields":
        return UserApiKeyFields("user_api_keys")

    @classmethod
    def system_api_keys(cls) -> "SystemApiKeyFields":
        return SystemApiKeyFields("system_api_keys")

    @classmethod
    def projects(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "ProjectConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectConnectionFields("projects", arguments=cleared_arguments)

    projects_last_updated_at: "QueryGraphQLField" = QueryGraphQLField(
        "projectsLastUpdatedAt"
    )

    @classmethod
    def datasets(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
        sort: Optional[DatasetSort] = None,
    ) -> "DatasetConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "sort": {"type": "DatasetSort", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetConnectionFields("datasets", arguments=cleared_arguments)

    datasets_last_updated_at: "QueryGraphQLField" = QueryGraphQLField(
        "datasetsLastUpdatedAt"
    )

    @classmethod
    def compare_experiments(
        cls, experiment_ids: Any, *, filter_condition: Optional[str] = None
    ) -> "ExperimentComparisonFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "experimentIds": {"type": "GlobalID!", "value": experiment_ids},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ExperimentComparisonFields(
            "compare_experiments", arguments=cleared_arguments
        )

    @classmethod
    def validate_experiment_run_filter_condition(
        cls, condition: str, experiment_ids: Any
    ) -> "ValidationResultFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "condition": {"type": "String!", "value": condition},
            "experimentIds": {"type": "GlobalID!", "value": experiment_ids},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ValidationResultFields(
            "validate_experiment_run_filter_condition", arguments=cleared_arguments
        )

    @classmethod
    def functionality(cls) -> "FunctionalityFields":
        return FunctionalityFields("functionality")

    @classmethod
    def model(cls) -> "ModelFields":
        return ModelFields("model")

    @classmethod
    def node(cls, id: Any) -> "NodeInterface":
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "GlobalID!", "value": id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeInterface("node", arguments=cleared_arguments)

    @classmethod
    def viewer(cls) -> "UserFields":
        return UserFields("viewer")

    @classmethod
    def prompts(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "PromptConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PromptConnectionFields("prompts", arguments=cleared_arguments)

    @classmethod
    def prompt_labels(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "PromptLabelConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PromptLabelConnectionFields("prompt_labels", arguments=cleared_arguments)

    @classmethod
    def clusters(cls, clusters: ClusterInput) -> "ClusterFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "clusters": {"type": "ClusterInput!", "value": clusters}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ClusterFields("clusters", arguments=cleared_arguments)

    @classmethod
    def hdbscan_clustering(
        cls,
        event_ids: str,
        min_cluster_size: int,
        cluster_min_samples: int,
        cluster_selection_epsilon: float,
        *,
        coordinates_2_d: Optional[InputCoordinate2D] = None,
        coordinates_3_d: Optional[InputCoordinate3D] = None,
    ) -> "ClusterFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "eventIds": {"type": "ID!", "value": event_ids},
            "coordinates2d": {"type": "InputCoordinate2D", "value": coordinates_2_d},
            "coordinates3d": {"type": "InputCoordinate3D", "value": coordinates_3_d},
            "minClusterSize": {"type": "Int!", "value": min_cluster_size},
            "clusterMinSamples": {"type": "Int!", "value": cluster_min_samples},
            "clusterSelectionEpsilon": {
                "type": "Float!",
                "value": cluster_selection_epsilon,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ClusterFields("hdbscan_clustering", arguments=cleared_arguments)

    db_storage_capacity_bytes: "QueryGraphQLField" = QueryGraphQLField(
        "dbStorageCapacityBytes"
    )

    @classmethod
    def db_table_stats(cls) -> "DbTableStatsFields":
        return DbTableStatsFields("db_table_stats")

    def fields(
        self,
        *subfields: Union[
            QueryGraphQLField,
            "ClusterFields",
            "DatasetConnectionFields",
            "DbTableStatsFields",
            "ExperimentComparisonFields",
            "FunctionalityFields",
            "GenerativeModelFields",
            "GenerativeProviderFields",
            "InvocationParameterUnion",
            "ModelFields",
            "NodeInterface",
            "ProjectConnectionFields",
            "PromptConnectionFields",
            "PromptLabelConnectionFields",
            "SystemApiKeyFields",
            "UserApiKeyFields",
            "UserConnectionFields",
            "UserFields",
            "UserRoleFields",
            "ValidationResultFields",
        ],
    ) -> "QueryFields":
        """Subfields should come from the QueryFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "QueryFields":
        self._alias = alias
        return self


class ResponseFormatFields(GraphQLField):
    definition: "ResponseFormatGraphQLField" = ResponseFormatGraphQLField("definition")

    def fields(self, *subfields: ResponseFormatGraphQLField) -> "ResponseFormatFields":
        """Subfields should come from the ResponseFormatFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ResponseFormatFields":
        self._alias = alias
        return self


class RetrievalFields(GraphQLField):
    query_id: "RetrievalGraphQLField" = RetrievalGraphQLField("queryId")
    document_id: "RetrievalGraphQLField" = RetrievalGraphQLField("documentId")
    relevance: "RetrievalGraphQLField" = RetrievalGraphQLField("relevance")

    def fields(self, *subfields: RetrievalGraphQLField) -> "RetrievalFields":
        """Subfields should come from the RetrievalFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RetrievalFields":
        self._alias = alias
        return self


class RunComparisonItemFields(GraphQLField):
    experiment_id: "RunComparisonItemGraphQLField" = RunComparisonItemGraphQLField(
        "experimentId"
    )

    @classmethod
    def runs(cls) -> "ExperimentRunFields":
        return ExperimentRunFields("runs")

    def fields(
        self, *subfields: Union[RunComparisonItemGraphQLField, "ExperimentRunFields"]
    ) -> "RunComparisonItemFields":
        """Subfields should come from the RunComparisonItemFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "RunComparisonItemFields":
        self._alias = alias
        return self


class SegmentFields(GraphQLField):
    bin: "BinUnion" = BinUnion("bin")

    @classmethod
    def counts(cls) -> "DatasetValuesFields":
        return DatasetValuesFields("counts")

    def fields(
        self, *subfields: Union[SegmentGraphQLField, "BinUnion", "DatasetValuesFields"]
    ) -> "SegmentFields":
        """Subfields should come from the SegmentFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SegmentFields":
        self._alias = alias
        return self


class SegmentsFields(GraphQLField):
    @classmethod
    def segments(cls) -> "SegmentFields":
        return SegmentFields("segments")

    @classmethod
    def total_counts(cls) -> "DatasetValuesFields":
        return DatasetValuesFields("total_counts")

    def fields(
        self,
        *subfields: Union[SegmentsGraphQLField, "DatasetValuesFields", "SegmentFields"],
    ) -> "SegmentsFields":
        """Subfields should come from the SegmentsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SegmentsFields":
        self._alias = alias
        return self


class SpanFields(GraphQLField):
    id: "SpanGraphQLField" = SpanGraphQLField("id")
    name: "SpanGraphQLField" = SpanGraphQLField("name")
    status_code: "SpanGraphQLField" = SpanGraphQLField("statusCode")
    status_message: "SpanGraphQLField" = SpanGraphQLField("statusMessage")
    start_time: "SpanGraphQLField" = SpanGraphQLField("startTime")
    end_time: "SpanGraphQLField" = SpanGraphQLField("endTime")
    latency_ms: "SpanGraphQLField" = SpanGraphQLField("latencyMs")
    parent_id: "SpanGraphQLField" = SpanGraphQLField("parentId")
    span_kind: "SpanGraphQLField" = SpanGraphQLField("spanKind")
    span_id: "SpanGraphQLField" = SpanGraphQLField("spanId")

    @classmethod
    def trace(cls) -> "TraceFields":
        return TraceFields("trace")

    @classmethod
    def context(cls) -> "SpanContextFields":
        return SpanContextFields("context")

    attributes: "SpanGraphQLField" = SpanGraphQLField("attributes")
    metadata: "SpanGraphQLField" = SpanGraphQLField("metadata")
    num_documents: "SpanGraphQLField" = SpanGraphQLField("numDocuments")
    token_count_total: "SpanGraphQLField" = SpanGraphQLField("tokenCountTotal")
    token_count_prompt: "SpanGraphQLField" = SpanGraphQLField("tokenCountPrompt")
    token_count_completion: "SpanGraphQLField" = SpanGraphQLField(
        "tokenCountCompletion"
    )

    @classmethod
    def input(cls) -> "SpanIOValueFields":
        return SpanIOValueFields("input")

    @classmethod
    def output(cls) -> "SpanIOValueFields":
        return SpanIOValueFields("output")

    @classmethod
    def events(cls) -> "SpanEventFields":
        return SpanEventFields("events")

    cumulative_token_count_total: "SpanGraphQLField" = SpanGraphQLField(
        "cumulativeTokenCountTotal"
    )
    cumulative_token_count_prompt: "SpanGraphQLField" = SpanGraphQLField(
        "cumulativeTokenCountPrompt"
    )
    cumulative_token_count_completion: "SpanGraphQLField" = SpanGraphQLField(
        "cumulativeTokenCountCompletion"
    )
    propagated_status_code: "SpanGraphQLField" = SpanGraphQLField(
        "propagatedStatusCode"
    )

    @classmethod
    def span_annotations(
        cls, *, sort: Optional[SpanAnnotationSort] = None
    ) -> "SpanAnnotationFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "SpanAnnotationSort", "value": sort}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SpanAnnotationFields("span_annotations", arguments=cleared_arguments)

    @classmethod
    def document_evaluations(cls) -> "DocumentEvaluationFields":
        return DocumentEvaluationFields("document_evaluations")

    @classmethod
    def document_retrieval_metrics(
        cls, *, evaluation_name: Optional[str] = None
    ) -> "DocumentRetrievalMetricsFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "evaluationName": {"type": "String", "value": evaluation_name}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DocumentRetrievalMetricsFields(
            "document_retrieval_metrics", arguments=cleared_arguments
        )

    num_child_spans: "SpanGraphQLField" = SpanGraphQLField("numChildSpans")

    @classmethod
    def descendants(
        cls,
        *,
        max_depth: Optional[int] = None,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "SpanConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "maxDepth": {"type": "Int", "value": max_depth},
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SpanConnectionFields("descendants", arguments=cleared_arguments)

    @classmethod
    def as_example_revision(cls) -> "SpanAsExampleRevisionFields":
        return SpanAsExampleRevisionFields("as_example_revision")

    @classmethod
    def project(cls) -> "ProjectFields":
        return ProjectFields("project")

    contained_in_dataset: "SpanGraphQLField" = SpanGraphQLField("containedInDataset")
    invocation_parameters: "InvocationParameterUnion" = InvocationParameterUnion(
        "invocationParameters"
    )

    def fields(
        self,
        *subfields: Union[
            SpanGraphQLField,
            "DocumentEvaluationFields",
            "DocumentRetrievalMetricsFields",
            "InvocationParameterUnion",
            "ProjectFields",
            "SpanAnnotationFields",
            "SpanAsExampleRevisionFields",
            "SpanConnectionFields",
            "SpanContextFields",
            "SpanEventFields",
            "SpanIOValueFields",
            "TraceFields",
        ],
    ) -> "SpanFields":
        """Subfields should come from the SpanFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanFields":
        self._alias = alias
        return self


class SpanAnnotationFields(GraphQLField):
    id: "SpanAnnotationGraphQLField" = SpanAnnotationGraphQLField("id")
    name: "SpanAnnotationGraphQLField" = SpanAnnotationGraphQLField("name")
    score: "SpanAnnotationGraphQLField" = SpanAnnotationGraphQLField("score")
    label: "SpanAnnotationGraphQLField" = SpanAnnotationGraphQLField("label")
    explanation: "SpanAnnotationGraphQLField" = SpanAnnotationGraphQLField(
        "explanation"
    )
    annotator_kind: "SpanAnnotationGraphQLField" = SpanAnnotationGraphQLField(
        "annotatorKind"
    )
    metadata: "SpanAnnotationGraphQLField" = SpanAnnotationGraphQLField("metadata")
    span_id: "SpanAnnotationGraphQLField" = SpanAnnotationGraphQLField("spanId")

    def fields(self, *subfields: SpanAnnotationGraphQLField) -> "SpanAnnotationFields":
        """Subfields should come from the SpanAnnotationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanAnnotationFields":
        self._alias = alias
        return self


class SpanAnnotationMutationPayloadFields(GraphQLField):
    @classmethod
    def span_annotations(cls) -> "SpanAnnotationFields":
        return SpanAnnotationFields("span_annotations")

    @classmethod
    def query(cls) -> "QueryFields":
        return QueryFields("query")

    def fields(
        self,
        *subfields: Union[
            SpanAnnotationMutationPayloadGraphQLField,
            "QueryFields",
            "SpanAnnotationFields",
        ],
    ) -> "SpanAnnotationMutationPayloadFields":
        """Subfields should come from the SpanAnnotationMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanAnnotationMutationPayloadFields":
        self._alias = alias
        return self


class SpanAsExampleRevisionFields(GraphQLField):
    input: "SpanAsExampleRevisionGraphQLField" = SpanAsExampleRevisionGraphQLField(
        "input"
    )
    output: "SpanAsExampleRevisionGraphQLField" = SpanAsExampleRevisionGraphQLField(
        "output"
    )
    metadata: "SpanAsExampleRevisionGraphQLField" = SpanAsExampleRevisionGraphQLField(
        "metadata"
    )

    def fields(
        self, *subfields: SpanAsExampleRevisionGraphQLField
    ) -> "SpanAsExampleRevisionFields":
        """Subfields should come from the SpanAsExampleRevisionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanAsExampleRevisionFields":
        self._alias = alias
        return self


class SpanConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "SpanEdgeFields":
        return SpanEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            SpanConnectionGraphQLField, "PageInfoFields", "SpanEdgeFields"
        ],
    ) -> "SpanConnectionFields":
        """Subfields should come from the SpanConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanConnectionFields":
        self._alias = alias
        return self


class SpanContextFields(GraphQLField):
    trace_id: "SpanContextGraphQLField" = SpanContextGraphQLField("traceId")
    span_id: "SpanContextGraphQLField" = SpanContextGraphQLField("spanId")

    def fields(self, *subfields: SpanContextGraphQLField) -> "SpanContextFields":
        """Subfields should come from the SpanContextFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanContextFields":
        self._alias = alias
        return self


class SpanEdgeFields(GraphQLField):
    cursor: "SpanEdgeGraphQLField" = SpanEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "SpanFields":
        return SpanFields("node")

    def fields(
        self, *subfields: Union[SpanEdgeGraphQLField, "SpanFields"]
    ) -> "SpanEdgeFields":
        """Subfields should come from the SpanEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanEdgeFields":
        self._alias = alias
        return self


class SpanEventFields(GraphQLField):
    name: "SpanEventGraphQLField" = SpanEventGraphQLField("name")
    message: "SpanEventGraphQLField" = SpanEventGraphQLField("message")
    timestamp: "SpanEventGraphQLField" = SpanEventGraphQLField("timestamp")

    def fields(self, *subfields: SpanEventGraphQLField) -> "SpanEventFields":
        """Subfields should come from the SpanEventFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanEventFields":
        self._alias = alias
        return self


class SpanIOValueFields(GraphQLField):
    mime_type: "SpanIOValueGraphQLField" = SpanIOValueGraphQLField("mimeType")
    truncated_value: "SpanIOValueGraphQLField" = SpanIOValueGraphQLField(
        "truncatedValue"
    )
    value: "SpanIOValueGraphQLField" = SpanIOValueGraphQLField("value")

    def fields(self, *subfields: SpanIOValueGraphQLField) -> "SpanIOValueFields":
        """Subfields should come from the SpanIOValueFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SpanIOValueFields":
        self._alias = alias
        return self


class StringInvocationParameterFields(GraphQLField):
    invocation_name: "StringInvocationParameterGraphQLField" = (
        StringInvocationParameterGraphQLField("invocationName")
    )
    canonical_name: "StringInvocationParameterGraphQLField" = (
        StringInvocationParameterGraphQLField("canonicalName")
    )
    label: "StringInvocationParameterGraphQLField" = (
        StringInvocationParameterGraphQLField("label")
    )
    required: "StringInvocationParameterGraphQLField" = (
        StringInvocationParameterGraphQLField("required")
    )
    invocation_input_field: "StringInvocationParameterGraphQLField" = (
        StringInvocationParameterGraphQLField("invocationInputField")
    )
    default_value: "StringInvocationParameterGraphQLField" = (
        StringInvocationParameterGraphQLField("defaultValue")
    )

    def fields(
        self, *subfields: StringInvocationParameterGraphQLField
    ) -> "StringInvocationParameterFields":
        """Subfields should come from the StringInvocationParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StringInvocationParameterFields":
        self._alias = alias
        return self


class StringListInvocationParameterFields(GraphQLField):
    invocation_name: "StringListInvocationParameterGraphQLField" = (
        StringListInvocationParameterGraphQLField("invocationName")
    )
    canonical_name: "StringListInvocationParameterGraphQLField" = (
        StringListInvocationParameterGraphQLField("canonicalName")
    )
    label: "StringListInvocationParameterGraphQLField" = (
        StringListInvocationParameterGraphQLField("label")
    )
    required: "StringListInvocationParameterGraphQLField" = (
        StringListInvocationParameterGraphQLField("required")
    )
    invocation_input_field: "StringListInvocationParameterGraphQLField" = (
        StringListInvocationParameterGraphQLField("invocationInputField")
    )
    default_value: "StringListInvocationParameterGraphQLField" = (
        StringListInvocationParameterGraphQLField("defaultValue")
    )

    def fields(
        self, *subfields: StringListInvocationParameterGraphQLField
    ) -> "StringListInvocationParameterFields":
        """Subfields should come from the StringListInvocationParameterFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "StringListInvocationParameterFields":
        self._alias = alias
        return self


class SystemApiKeyFields(GraphQLField):
    name: "SystemApiKeyGraphQLField" = SystemApiKeyGraphQLField("name")
    description: "SystemApiKeyGraphQLField" = SystemApiKeyGraphQLField("description")
    created_at: "SystemApiKeyGraphQLField" = SystemApiKeyGraphQLField("createdAt")
    expires_at: "SystemApiKeyGraphQLField" = SystemApiKeyGraphQLField("expiresAt")
    id: "SystemApiKeyGraphQLField" = SystemApiKeyGraphQLField("id")

    def fields(self, *subfields: SystemApiKeyGraphQLField) -> "SystemApiKeyFields":
        """Subfields should come from the SystemApiKeyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "SystemApiKeyFields":
        self._alias = alias
        return self


class TextContentPartFields(GraphQLField):
    @classmethod
    def text(cls) -> "TextContentValueFields":
        return TextContentValueFields("text")

    def fields(
        self, *subfields: Union[TextContentPartGraphQLField, "TextContentValueFields"]
    ) -> "TextContentPartFields":
        """Subfields should come from the TextContentPartFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TextContentPartFields":
        self._alias = alias
        return self


class TextContentValueFields(GraphQLField):
    text: "TextContentValueGraphQLField" = TextContentValueGraphQLField("text")

    def fields(
        self, *subfields: TextContentValueGraphQLField
    ) -> "TextContentValueFields":
        """Subfields should come from the TextContentValueFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TextContentValueFields":
        self._alias = alias
        return self


class TimeSeriesInterface(GraphQLField):
    @classmethod
    def data(cls) -> "TimeSeriesDataPointFields":
        return TimeSeriesDataPointFields("data")

    def fields(
        self, *subfields: Union[TimeSeriesGraphQLField, "TimeSeriesDataPointFields"]
    ) -> "TimeSeriesInterface":
        """Subfields should come from the TimeSeriesInterface class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TimeSeriesInterface":
        self._alias = alias
        return self

    def on(self, type_name: str, *subfields: GraphQLField) -> "TimeSeriesInterface":
        self._inline_fragments[type_name] = subfields
        return self


class TimeSeriesDataPointFields(GraphQLField):
    timestamp: "TimeSeriesDataPointGraphQLField" = TimeSeriesDataPointGraphQLField(
        "timestamp"
    )
    value: "TimeSeriesDataPointGraphQLField" = TimeSeriesDataPointGraphQLField("value")

    def fields(
        self, *subfields: TimeSeriesDataPointGraphQLField
    ) -> "TimeSeriesDataPointFields":
        """Subfields should come from the TimeSeriesDataPointFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TimeSeriesDataPointFields":
        self._alias = alias
        return self


class TokenUsageFields(GraphQLField):
    prompt: "TokenUsageGraphQLField" = TokenUsageGraphQLField("prompt")
    completion: "TokenUsageGraphQLField" = TokenUsageGraphQLField("completion")
    total: "TokenUsageGraphQLField" = TokenUsageGraphQLField("total")

    def fields(self, *subfields: TokenUsageGraphQLField) -> "TokenUsageFields":
        """Subfields should come from the TokenUsageFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TokenUsageFields":
        self._alias = alias
        return self


class ToolCallContentPartFields(GraphQLField):
    @classmethod
    def tool_call(cls) -> "ToolCallContentValueFields":
        return ToolCallContentValueFields("tool_call")

    def fields(
        self,
        *subfields: Union[
            ToolCallContentPartGraphQLField, "ToolCallContentValueFields"
        ],
    ) -> "ToolCallContentPartFields":
        """Subfields should come from the ToolCallContentPartFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ToolCallContentPartFields":
        self._alias = alias
        return self


class ToolCallContentValueFields(GraphQLField):
    tool_call_id: "ToolCallContentValueGraphQLField" = ToolCallContentValueGraphQLField(
        "toolCallId"
    )

    @classmethod
    def tool_call(cls) -> "ToolCallFunctionFields":
        return ToolCallFunctionFields("tool_call")

    def fields(
        self,
        *subfields: Union[ToolCallContentValueGraphQLField, "ToolCallFunctionFields"],
    ) -> "ToolCallContentValueFields":
        """Subfields should come from the ToolCallContentValueFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ToolCallContentValueFields":
        self._alias = alias
        return self


class ToolCallFunctionFields(GraphQLField):
    name: "ToolCallFunctionGraphQLField" = ToolCallFunctionGraphQLField("name")
    arguments: "ToolCallFunctionGraphQLField" = ToolCallFunctionGraphQLField(
        "arguments"
    )

    def fields(
        self, *subfields: ToolCallFunctionGraphQLField
    ) -> "ToolCallFunctionFields":
        """Subfields should come from the ToolCallFunctionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ToolCallFunctionFields":
        self._alias = alias
        return self


class ToolDefinitionFields(GraphQLField):
    definition: "ToolDefinitionGraphQLField" = ToolDefinitionGraphQLField("definition")

    def fields(self, *subfields: ToolDefinitionGraphQLField) -> "ToolDefinitionFields":
        """Subfields should come from the ToolDefinitionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ToolDefinitionFields":
        self._alias = alias
        return self


class ToolResultContentPartFields(GraphQLField):
    @classmethod
    def tool_result(cls) -> "ToolResultContentValueFields":
        return ToolResultContentValueFields("tool_result")

    def fields(
        self,
        *subfields: Union[
            ToolResultContentPartGraphQLField, "ToolResultContentValueFields"
        ],
    ) -> "ToolResultContentPartFields":
        """Subfields should come from the ToolResultContentPartFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ToolResultContentPartFields":
        self._alias = alias
        return self


class ToolResultContentValueFields(GraphQLField):
    tool_call_id: "ToolResultContentValueGraphQLField" = (
        ToolResultContentValueGraphQLField("toolCallId")
    )
    result: "ToolResultContentValueGraphQLField" = ToolResultContentValueGraphQLField(
        "result"
    )

    def fields(
        self, *subfields: ToolResultContentValueGraphQLField
    ) -> "ToolResultContentValueFields":
        """Subfields should come from the ToolResultContentValueFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ToolResultContentValueFields":
        self._alias = alias
        return self


class TraceFields(GraphQLField):
    id: "TraceGraphQLField" = TraceGraphQLField("id")
    trace_id: "TraceGraphQLField" = TraceGraphQLField("traceId")
    start_time: "TraceGraphQLField" = TraceGraphQLField("startTime")
    end_time: "TraceGraphQLField" = TraceGraphQLField("endTime")
    latency_ms: "TraceGraphQLField" = TraceGraphQLField("latencyMs")

    @classmethod
    def project(cls) -> "ProjectFields":
        return ProjectFields("project")

    project_id: "TraceGraphQLField" = TraceGraphQLField("projectId")
    project_session_id: "TraceGraphQLField" = TraceGraphQLField("projectSessionId")

    @classmethod
    def session(cls) -> "ProjectSessionFields":
        return ProjectSessionFields("session")

    @classmethod
    def root_span(cls) -> "SpanFields":
        return SpanFields("root_span")

    num_spans: "TraceGraphQLField" = TraceGraphQLField("numSpans")

    @classmethod
    def spans(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> "SpanConnectionFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return SpanConnectionFields("spans", arguments=cleared_arguments)

    @classmethod
    def span_annotations(
        cls, *, sort: Optional[TraceAnnotationSort] = None
    ) -> "TraceAnnotationFields":
        arguments: Dict[str, Dict[str, Any]] = {
            "sort": {"type": "TraceAnnotationSort", "value": sort}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return TraceAnnotationFields("span_annotations", arguments=cleared_arguments)

    def fields(
        self,
        *subfields: Union[
            TraceGraphQLField,
            "ProjectFields",
            "ProjectSessionFields",
            "SpanConnectionFields",
            "SpanFields",
            "TraceAnnotationFields",
        ],
    ) -> "TraceFields":
        """Subfields should come from the TraceFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TraceFields":
        self._alias = alias
        return self


class TraceAnnotationFields(GraphQLField):
    id: "TraceAnnotationGraphQLField" = TraceAnnotationGraphQLField("id")
    name: "TraceAnnotationGraphQLField" = TraceAnnotationGraphQLField("name")
    annotator_kind: "TraceAnnotationGraphQLField" = TraceAnnotationGraphQLField(
        "annotatorKind"
    )
    label: "TraceAnnotationGraphQLField" = TraceAnnotationGraphQLField("label")
    score: "TraceAnnotationGraphQLField" = TraceAnnotationGraphQLField("score")
    explanation: "TraceAnnotationGraphQLField" = TraceAnnotationGraphQLField(
        "explanation"
    )
    metadata: "TraceAnnotationGraphQLField" = TraceAnnotationGraphQLField("metadata")
    trace_id: "TraceAnnotationGraphQLField" = TraceAnnotationGraphQLField("traceId")

    def fields(
        self, *subfields: TraceAnnotationGraphQLField
    ) -> "TraceAnnotationFields":
        """Subfields should come from the TraceAnnotationFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TraceAnnotationFields":
        self._alias = alias
        return self


class TraceAnnotationMutationPayloadFields(GraphQLField):
    @classmethod
    def trace_annotations(cls) -> "TraceAnnotationFields":
        return TraceAnnotationFields("trace_annotations")

    @classmethod
    def query(cls) -> "QueryFields":
        return QueryFields("query")

    def fields(
        self,
        *subfields: Union[
            TraceAnnotationMutationPayloadGraphQLField,
            "QueryFields",
            "TraceAnnotationFields",
        ],
    ) -> "TraceAnnotationMutationPayloadFields":
        """Subfields should come from the TraceAnnotationMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TraceAnnotationMutationPayloadFields":
        self._alias = alias
        return self


class TraceConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "TraceEdgeFields":
        return TraceEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            TraceConnectionGraphQLField, "PageInfoFields", "TraceEdgeFields"
        ],
    ) -> "TraceConnectionFields":
        """Subfields should come from the TraceConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TraceConnectionFields":
        self._alias = alias
        return self


class TraceEdgeFields(GraphQLField):
    cursor: "TraceEdgeGraphQLField" = TraceEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "TraceFields":
        return TraceFields("node")

    def fields(
        self, *subfields: Union[TraceEdgeGraphQLField, "TraceFields"]
    ) -> "TraceEdgeFields":
        """Subfields should come from the TraceEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "TraceEdgeFields":
        self._alias = alias
        return self


class UMAPPointFields(GraphQLField):
    id: "UMAPPointGraphQLField" = UMAPPointGraphQLField("id")
    event_id: "UMAPPointGraphQLField" = UMAPPointGraphQLField("eventId")
    coordinates: "Point2DPoint3DUnion" = Point2DPoint3DUnion("coordinates")

    @classmethod
    def embedding_metadata(cls) -> "EmbeddingMetadataFields":
        return EmbeddingMetadataFields("embedding_metadata")

    @classmethod
    def event_metadata(cls) -> "EventMetadataFields":
        return EventMetadataFields("event_metadata")

    def fields(
        self,
        *subfields: Union[
            UMAPPointGraphQLField,
            "EmbeddingMetadataFields",
            "EventMetadataFields",
            "Point2DPoint3DUnion",
        ],
    ) -> "UMAPPointFields":
        """Subfields should come from the UMAPPointFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UMAPPointFields":
        self._alias = alias
        return self


class UMAPPointsFields(GraphQLField):
    @classmethod
    def data(cls) -> "UMAPPointFields":
        return UMAPPointFields("data")

    @classmethod
    def reference_data(cls) -> "UMAPPointFields":
        return UMAPPointFields("reference_data")

    @classmethod
    def clusters(cls) -> "ClusterFields":
        return ClusterFields("clusters")

    @classmethod
    def corpus_data(cls) -> "UMAPPointFields":
        return UMAPPointFields("corpus_data")

    @classmethod
    def context_retrievals(cls) -> "RetrievalFields":
        return RetrievalFields("context_retrievals")

    def fields(
        self,
        *subfields: Union[
            UMAPPointsGraphQLField,
            "ClusterFields",
            "RetrievalFields",
            "UMAPPointFields",
        ],
    ) -> "UMAPPointsFields":
        """Subfields should come from the UMAPPointsFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UMAPPointsFields":
        self._alias = alias
        return self


class UserFields(GraphQLField):
    id: "UserGraphQLField" = UserGraphQLField("id")
    password_needs_reset: "UserGraphQLField" = UserGraphQLField("passwordNeedsReset")
    email: "UserGraphQLField" = UserGraphQLField("email")
    username: "UserGraphQLField" = UserGraphQLField("username")
    profile_picture_url: "UserGraphQLField" = UserGraphQLField("profilePictureUrl")
    created_at: "UserGraphQLField" = UserGraphQLField("createdAt")
    auth_method: "UserGraphQLField" = UserGraphQLField("authMethod")

    @classmethod
    def role(cls) -> "UserRoleFields":
        return UserRoleFields("role")

    @classmethod
    def api_keys(cls) -> "UserApiKeyFields":
        return UserApiKeyFields("api_keys")

    def fields(
        self, *subfields: Union[UserGraphQLField, "UserApiKeyFields", "UserRoleFields"]
    ) -> "UserFields":
        """Subfields should come from the UserFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserFields":
        self._alias = alias
        return self


class UserApiKeyFields(GraphQLField):
    name: "UserApiKeyGraphQLField" = UserApiKeyGraphQLField("name")
    description: "UserApiKeyGraphQLField" = UserApiKeyGraphQLField("description")
    created_at: "UserApiKeyGraphQLField" = UserApiKeyGraphQLField("createdAt")
    expires_at: "UserApiKeyGraphQLField" = UserApiKeyGraphQLField("expiresAt")
    id: "UserApiKeyGraphQLField" = UserApiKeyGraphQLField("id")

    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self, *subfields: Union[UserApiKeyGraphQLField, "UserFields"]
    ) -> "UserApiKeyFields":
        """Subfields should come from the UserApiKeyFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserApiKeyFields":
        self._alias = alias
        return self


class UserConnectionFields(GraphQLField):
    @classmethod
    def page_info(cls) -> "PageInfoFields":
        return PageInfoFields("page_info")

    @classmethod
    def edges(cls) -> "UserEdgeFields":
        return UserEdgeFields("edges")

    def fields(
        self,
        *subfields: Union[
            UserConnectionGraphQLField, "PageInfoFields", "UserEdgeFields"
        ],
    ) -> "UserConnectionFields":
        """Subfields should come from the UserConnectionFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserConnectionFields":
        self._alias = alias
        return self


class UserEdgeFields(GraphQLField):
    cursor: "UserEdgeGraphQLField" = UserEdgeGraphQLField("cursor")

    @classmethod
    def node(cls) -> "UserFields":
        return UserFields("node")

    def fields(
        self, *subfields: Union[UserEdgeGraphQLField, "UserFields"]
    ) -> "UserEdgeFields":
        """Subfields should come from the UserEdgeFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserEdgeFields":
        self._alias = alias
        return self


class UserMutationPayloadFields(GraphQLField):
    @classmethod
    def user(cls) -> "UserFields":
        return UserFields("user")

    def fields(
        self, *subfields: Union[UserMutationPayloadGraphQLField, "UserFields"]
    ) -> "UserMutationPayloadFields":
        """Subfields should come from the UserMutationPayloadFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserMutationPayloadFields":
        self._alias = alias
        return self


class UserRoleFields(GraphQLField):
    id: "UserRoleGraphQLField" = UserRoleGraphQLField("id")
    name: "UserRoleGraphQLField" = UserRoleGraphQLField("name")

    def fields(self, *subfields: UserRoleGraphQLField) -> "UserRoleFields":
        """Subfields should come from the UserRoleFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "UserRoleFields":
        self._alias = alias
        return self


class ValidationResultFields(GraphQLField):
    is_valid: "ValidationResultGraphQLField" = ValidationResultGraphQLField("isValid")
    error_message: "ValidationResultGraphQLField" = ValidationResultGraphQLField(
        "errorMessage"
    )

    def fields(
        self, *subfields: ValidationResultGraphQLField
    ) -> "ValidationResultFields":
        """Subfields should come from the ValidationResultFields class"""
        self._subfields.extend(subfields)
        return self

    def alias(self, alias: str) -> "ValidationResultFields":
        self._alias = alias
        return self
