# Generated by ariadne-codegen

from typing import Any, Dict, Optional

from .custom_fields import (
    ClusterFields,
    DatasetConnectionFields,
    DbTableStatsFields,
    ExperimentComparisonFields,
    FunctionalityFields,
    GenerativeModelFields,
    GenerativeProviderFields,
    ModelFields,
    NodeInterface,
    ProjectConnectionFields,
    PromptConnectionFields,
    PromptLabelConnectionFields,
    SystemApiKeyFields,
    UserApiKeyFields,
    UserConnectionFields,
    UserFields,
    UserRoleFields,
    ValidationResultFields,
)
from .custom_typing_fields import GraphQLField, InvocationParameterUnion
from .input_types import (
    ClusterInput,
    DatasetSort,
    InputCoordinate2D,
    InputCoordinate3D,
    ModelsInput,
)


class Query:
    @classmethod
    def model_providers(cls) -> GenerativeProviderFields:
        return GenerativeProviderFields(field_name="modelProviders")

    @classmethod
    def models(cls, *, input: Optional[ModelsInput] = None) -> GenerativeModelFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "ModelsInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return GenerativeModelFields(field_name="models", arguments=cleared_arguments)

    @classmethod
    def model_invocation_parameters(
        cls, *, input: Optional[ModelsInput] = None
    ) -> InvocationParameterUnion:
        arguments: Dict[str, Dict[str, Any]] = {
            "input": {"type": "ModelsInput", "value": input}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return InvocationParameterUnion(
            field_name="modelInvocationParameters", arguments=cleared_arguments
        )

    @classmethod
    def users(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> UserConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return UserConnectionFields(field_name="users", arguments=cleared_arguments)

    @classmethod
    def user_roles(cls) -> UserRoleFields:
        return UserRoleFields(field_name="userRoles")

    @classmethod
    def user_api_keys(cls) -> UserApiKeyFields:
        return UserApiKeyFields(field_name="userApiKeys")

    @classmethod
    def system_api_keys(cls) -> SystemApiKeyFields:
        return SystemApiKeyFields(field_name="systemApiKeys")

    @classmethod
    def projects(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> ProjectConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ProjectConnectionFields(
            field_name="projects", arguments=cleared_arguments
        )

    @classmethod
    def projects_last_updated_at(cls) -> GraphQLField:
        return GraphQLField(field_name="projectsLastUpdatedAt")

    @classmethod
    def datasets(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
        sort: Optional[DatasetSort] = None,
    ) -> DatasetConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
            "sort": {"type": "DatasetSort", "value": sort},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return DatasetConnectionFields(
            field_name="datasets", arguments=cleared_arguments
        )

    @classmethod
    def datasets_last_updated_at(cls) -> GraphQLField:
        return GraphQLField(field_name="datasetsLastUpdatedAt")

    @classmethod
    def compare_experiments(
        cls, experiment_ids: Any, *, filter_condition: Optional[str] = None
    ) -> ExperimentComparisonFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "experimentIds": {"type": "GlobalID!", "value": experiment_ids},
            "filterCondition": {"type": "String", "value": filter_condition},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ExperimentComparisonFields(
            field_name="compareExperiments", arguments=cleared_arguments
        )

    @classmethod
    def validate_experiment_run_filter_condition(
        cls, condition: str, experiment_ids: Any
    ) -> ValidationResultFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "condition": {"type": "String!", "value": condition},
            "experimentIds": {"type": "GlobalID!", "value": experiment_ids},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ValidationResultFields(
            field_name="validateExperimentRunFilterCondition",
            arguments=cleared_arguments,
        )

    @classmethod
    def functionality(cls) -> FunctionalityFields:
        return FunctionalityFields(field_name="functionality")

    @classmethod
    def model(cls) -> ModelFields:
        return ModelFields(field_name="model")

    @classmethod
    def node(cls, id: Any) -> NodeInterface:
        arguments: Dict[str, Dict[str, Any]] = {
            "id": {"type": "GlobalID!", "value": id}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return NodeInterface(field_name="node", arguments=cleared_arguments)

    @classmethod
    def viewer(cls) -> UserFields:
        return UserFields(field_name="viewer")

    @classmethod
    def prompts(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> PromptConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PromptConnectionFields(field_name="prompts", arguments=cleared_arguments)

    @classmethod
    def prompt_labels(
        cls,
        *,
        first: Optional[int] = None,
        last: Optional[int] = None,
        after: Optional[str] = None,
        before: Optional[str] = None,
    ) -> PromptLabelConnectionFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "first": {"type": "Int", "value": first},
            "last": {"type": "Int", "value": last},
            "after": {"type": "String", "value": after},
            "before": {"type": "String", "value": before},
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return PromptLabelConnectionFields(
            field_name="promptLabels", arguments=cleared_arguments
        )

    @classmethod
    def clusters(cls, clusters: ClusterInput) -> ClusterFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "clusters": {"type": "ClusterInput!", "value": clusters}
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ClusterFields(field_name="clusters", arguments=cleared_arguments)

    @classmethod
    def hdbscan_clustering(
        cls,
        event_ids: str,
        min_cluster_size: int,
        cluster_min_samples: int,
        cluster_selection_epsilon: float,
        *,
        coordinates_2_d: Optional[InputCoordinate2D] = None,
        coordinates_3_d: Optional[InputCoordinate3D] = None,
    ) -> ClusterFields:
        arguments: Dict[str, Dict[str, Any]] = {
            "eventIds": {"type": "ID!", "value": event_ids},
            "coordinates2d": {"type": "InputCoordinate2D", "value": coordinates_2_d},
            "coordinates3d": {"type": "InputCoordinate3D", "value": coordinates_3_d},
            "minClusterSize": {"type": "Int!", "value": min_cluster_size},
            "clusterMinSamples": {"type": "Int!", "value": cluster_min_samples},
            "clusterSelectionEpsilon": {
                "type": "Float!",
                "value": cluster_selection_epsilon,
            },
        }
        cleared_arguments = {
            key: value for key, value in arguments.items() if value["value"] is not None
        }
        return ClusterFields(
            field_name="hdbscanClustering", arguments=cleared_arguments
        )

    @classmethod
    def db_storage_capacity_bytes(cls) -> GraphQLField:
        return GraphQLField(field_name="dbStorageCapacityBytes")

    @classmethod
    def db_table_stats(cls) -> DbTableStatsFields:
        return DbTableStatsFields(field_name="dbTableStats")
