# generated by datamodel-codegen:
#   filename:  schema.graphql

from __future__ import annotations

from enum import Enum
from typing import Literal, Optional, TypeAlias, Union

from pydantic import BaseModel, ConfigDict, Field

Boolean: TypeAlias = bool
"""
The `Boolean` scalar type represents `true` or `false`.
"""


DateTime: TypeAlias = str
"""
Date with time (isoformat)
"""


Float: TypeAlias = float
"""
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
"""


GlobalID: TypeAlias = str
"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""


ID: TypeAlias = str
"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""


Identifier: TypeAlias = str


Int: TypeAlias = int
"""
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
"""


JSON: TypeAlias = str
"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf).
"""


String: TypeAlias = str
"""
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
"""


Void: TypeAlias = str
"""
Represents NULL values
"""


class AnnotatorKind(Enum):
    HUMAN = "HUMAN"
    LLM = "LLM"


class AuthMethod(Enum):
    LOCAL = "LOCAL"
    OAUTH2 = "OAUTH2"


class CanonicalParameterName(Enum):
    ANTHROPIC_EXTENDED_THINKING = "ANTHROPIC_EXTENDED_THINKING"
    MAX_COMPLETION_TOKENS = "MAX_COMPLETION_TOKENS"
    RANDOM_SEED = "RANDOM_SEED"
    REASONING_EFFORT = "REASONING_EFFORT"
    RESPONSE_FORMAT = "RESPONSE_FORMAT"
    STOP_SEQUENCES = "STOP_SEQUENCES"
    TEMPERATURE = "TEMPERATURE"
    TOOL_CHOICE = "TOOL_CHOICE"
    TOP_P = "TOP_P"


class ChatCompletionMessageRole(Enum):
    AI = "AI"
    SYSTEM = "SYSTEM"
    TOOL = "TOOL"
    USER = "USER"


class DataQualityMetric(Enum):
    cardinality = "cardinality"
    count = "count"
    max = "max"
    mean = "mean"
    min = "min"
    p01 = "p01"
    p25 = "p25"
    p50 = "p50"
    p75 = "p75"
    p99 = "p99"
    percentEmpty = "percentEmpty"
    sum = "sum"


class DatasetColumn(Enum):
    createdAt = "createdAt"
    name = "name"


class DatasetVersionColumn(Enum):
    createdAt = "createdAt"


class DimensionDataType(Enum):
    categorical = "categorical"
    numeric = "numeric"


class DimensionShape(Enum):
    continuous = "continuous"
    discrete = "discrete"


class DimensionType(Enum):
    actual = "actual"
    feature = "feature"
    prediction = "prediction"
    tag = "tag"


class EvalAttr(Enum):
    label = "label"
    score = "score"


class ExperimentRunAnnotatorKind(Enum):
    CODE = "CODE"
    HUMAN = "HUMAN"
    LLM = "LLM"


class GenerativeProviderKey(Enum):
    ANTHROPIC = "ANTHROPIC"
    AZURE_OPENAI = "AZURE_OPENAI"
    GOOGLE = "GOOGLE"
    OPENAI = "OPENAI"


class InferencesRole(Enum):
    primary = "primary"
    reference = "reference"


class InvocationInputField(Enum):
    value_bool = "value_bool"
    value_boolean = "value_boolean"
    value_float = "value_float"
    value_int = "value_int"
    value_json = "value_json"
    value_string = "value_string"
    value_string_list = "value_string_list"


class MimeType(Enum):
    json = "json"
    text = "text"


class ModelProvider(Enum):
    ANTHROPIC = "ANTHROPIC"
    AZURE_OPENAI = "AZURE_OPENAI"
    GOOGLE = "GOOGLE"
    OPENAI = "OPENAI"


class PerformanceMetric(Enum):
    accuracyScore = "accuracyScore"


class ProjectSessionColumn(Enum):
    endTime = "endTime"
    numTraces = "numTraces"
    startTime = "startTime"
    tokenCountTotal = "tokenCountTotal"


class PromptMessageRole(Enum):
    AI = "AI"
    SYSTEM = "SYSTEM"
    TOOL = "TOOL"
    USER = "USER"


class PromptTemplateFormat(Enum):
    F_STRING = "F_STRING"
    MUSTACHE = "MUSTACHE"
    NONE = "NONE"


class PromptTemplateType(Enum):
    CHAT = "CHAT"
    STRING = "STRING"


class RevisionKind(Enum):
    CREATE = "CREATE"
    DELETE = "DELETE"
    PATCH = "PATCH"


class ScalarDriftMetric(Enum):
    jsDistance = "jsDistance"
    klDivergence = "klDivergence"
    psi = "psi"


class SortDir(Enum):
    asc = "asc"
    desc = "desc"


class SpanAnnotationColumn(Enum):
    createdAt = "createdAt"
    name = "name"


class SpanColumn(Enum):
    cumulativeTokenCountCompletion = "cumulativeTokenCountCompletion"
    cumulativeTokenCountPrompt = "cumulativeTokenCountPrompt"
    cumulativeTokenCountTotal = "cumulativeTokenCountTotal"
    endTime = "endTime"
    latencyMs = "latencyMs"
    startTime = "startTime"
    tokenCountCompletion = "tokenCountCompletion"
    tokenCountPrompt = "tokenCountPrompt"
    tokenCountTotal = "tokenCountTotal"


class SpanKind(Enum):
    agent = "agent"
    chain = "chain"
    embedding = "embedding"
    evaluator = "evaluator"
    guardrail = "guardrail"
    llm = "llm"
    reranker = "reranker"
    retriever = "retriever"
    tool = "tool"
    unknown = "unknown"


class SpanStatusCode(Enum):
    ERROR = "ERROR"
    OK = "OK"
    UNSET = "UNSET"


class TraceAnnotationColumn(Enum):
    createdAt = "createdAt"
    name = "name"


class UserRoleInput(Enum):
    ADMIN = "ADMIN"
    MEMBER = "MEMBER"


class VectorDriftMetric(Enum):
    euclideanDistance = "euclideanDistance"


class Annotation(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    explanation: Optional[String] = Field(
        default=None,
        description=(
            "The annotator's explanation for the annotation result (i.e. score or"
            " label, or both) given to the subject."
        ),
    )
    label: Optional[String] = Field(
        default=None,
        description=(
            "Value of the annotation in the form of a string, e.g. 'helpful' or 'not"
            " helpful'. Note that the label is not necessarily binary."
        ),
    )
    name: String = Field(
        ..., description="Name of the annotation, e.g. 'helpfulness' or 'relevance'."
    )
    score: Optional[Float] = Field(
        default=None,
        description="Value of the annotation in the form of a numeric score.",
    )
    typename__: Optional[Literal["Annotation"]] = Field(
        "Annotation", alias="__typename"
    )


class ApiKey(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime = Field(
        ..., description="The date and time the API key was created."
    )
    description: Optional[String] = Field(
        default=None, description="Description of the API key."
    )
    expiresAt: Optional[DateTime] = Field(
        default=None, description="The date and time the API key will expire."
    )
    name: String = Field(..., description="Name of the API key.")
    typename__: Optional[Literal["ApiKey"]] = Field("ApiKey", alias="__typename")


class ChatCompletionSubscriptionPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetExampleId: Optional[GlobalID] = None
    typename__: Optional[Literal["ChatCompletionSubscriptionPayload"]] = Field(
        "ChatCompletionSubscriptionPayload", alias="__typename"
    )


class ExampleRevision(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    input: JSON
    metadata: JSON
    output: JSON
    typename__: Optional[Literal["ExampleRevision"]] = Field(
        "ExampleRevision", alias="__typename"
    )


class InvocationParameterBase(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    invocationName: String
    label: String
    required: Boolean
    typename__: Optional[Literal["InvocationParameterBase"]] = Field(
        "InvocationParameterBase", alias="__typename"
    )


class Node(BaseModel):
    """
    An object with a Globally Unique ID
    """

    model_config = ConfigDict(
        frozen=True,
    )
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    typename__: Optional[Literal["Node"]] = Field("Node", alias="__typename")


class TimeSeries(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    data: list[TimeSeriesDataPoint]
    typename__: Optional[Literal["TimeSeries"]] = Field(
        "TimeSeries", alias="__typename"
    )


class AnnotationSummary(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Int
    labelCount: Int
    labelFractions: list[LabelFraction]
    labels: list[String]
    meanScore: Optional[Float] = None
    scoreCount: Int
    typename__: Optional[Literal["AnnotationSummary"]] = Field(
        "AnnotationSummary", alias="__typename"
    )


class BooleanInvocationParameter(InvocationParameterBase):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    defaultValue: Optional[Boolean] = None
    invocationInputField: InvocationInputField
    invocationName: String
    label: String
    required: Boolean
    typename__: Optional[Literal["BooleanInvocationParameter"]] = Field(
        "BooleanInvocationParameter", alias="__typename"
    )


class BoundedFloatInvocationParameter(InvocationParameterBase):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    defaultValue: Optional[Float] = None
    invocationInputField: InvocationInputField
    invocationName: String
    label: String
    maxValue: Float
    minValue: Float
    required: Boolean
    typename__: Optional[Literal["BoundedFloatInvocationParameter"]] = Field(
        "BoundedFloatInvocationParameter", alias="__typename"
    )


class ChatCompletionFunctionCall(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    arguments: String
    name: String
    typename__: Optional[Literal["ChatCompletionFunctionCall"]] = Field(
        "ChatCompletionFunctionCall", alias="__typename"
    )


class ChatCompletionMutationError(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    message: String
    typename__: Optional[Literal["ChatCompletionMutationError"]] = Field(
        "ChatCompletionMutationError", alias="__typename"
    )


class ChatCompletionMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    content: Optional[String] = None
    errorMessage: Optional[String] = None
    span: Span
    toolCalls: list[ChatCompletionToolCall]
    typename__: Optional[Literal["ChatCompletionMutationPayload"]] = Field(
        "ChatCompletionMutationPayload", alias="__typename"
    )


class ChatCompletionOverDatasetMutationExamplePayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetExampleId: GlobalID
    experimentRunId: GlobalID
    result: ChatCompletionMutationPayloadChatCompletionMutationError
    typename__: Optional[Literal["ChatCompletionOverDatasetMutationExamplePayload"]] = (
        Field("ChatCompletionOverDatasetMutationExamplePayload", alias="__typename")
    )


class ChatCompletionOverDatasetMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetId: GlobalID
    datasetVersionId: GlobalID
    examples: list[ChatCompletionOverDatasetMutationExamplePayload]
    experimentId: GlobalID
    typename__: Optional[Literal["ChatCompletionOverDatasetMutationPayload"]] = Field(
        "ChatCompletionOverDatasetMutationPayload", alias="__typename"
    )


class ChatCompletionSubscriptionError(ChatCompletionSubscriptionPayload):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetExampleId: Optional[GlobalID] = None
    message: String
    typename__: Optional[Literal["ChatCompletionSubscriptionError"]] = Field(
        "ChatCompletionSubscriptionError", alias="__typename"
    )


class ChatCompletionSubscriptionExperiment(ChatCompletionSubscriptionPayload):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetExampleId: Optional[GlobalID] = None
    experiment: Experiment
    typename__: Optional[Literal["ChatCompletionSubscriptionExperiment"]] = Field(
        "ChatCompletionSubscriptionExperiment", alias="__typename"
    )


class ChatCompletionSubscriptionResult(ChatCompletionSubscriptionPayload):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetExampleId: Optional[GlobalID] = None
    experimentRun: Optional[ExperimentRun] = None
    span: Optional[Span] = None
    typename__: Optional[Literal["ChatCompletionSubscriptionResult"]] = Field(
        "ChatCompletionSubscriptionResult", alias="__typename"
    )


class ChatCompletionToolCall(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    function: ChatCompletionFunctionCall
    id: String
    typename__: Optional[Literal["ChatCompletionToolCall"]] = Field(
        "ChatCompletionToolCall", alias="__typename"
    )


class Cluster(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    dataQualityMetric: DatasetValues = Field(
        ...,
        description=(
            "Data quality metric summarized by the respective datasets of the clustered"
            " events"
        ),
    )
    driftRatio: Optional[Float] = Field(
        default=None, description="Ratio of primary points over reference points"
    )
    eventIds: list[ID] = Field(
        ..., description="The event IDs of the points in the cluster"
    )
    id: ID = Field(..., description="The ID of the cluster")
    performanceMetric: DatasetValues = Field(
        ...,
        description=(
            "Performance metric summarized by the respective datasets of the clustered"
            " events"
        ),
    )
    primaryToCorpusRatio: Optional[Float] = Field(
        default=None, description="Ratio of primary points over corpus points"
    )
    typename__: Optional[Literal["Cluster"]] = Field("Cluster", alias="__typename")


class CreateSystemApiKeyMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    apiKey: SystemApiKey
    jwt: String
    query: Query
    typename__: Optional[Literal["CreateSystemApiKeyMutationPayload"]] = Field(
        "CreateSystemApiKeyMutationPayload", alias="__typename"
    )


class CreateUserApiKeyMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    apiKey: UserApiKey
    jwt: String
    query: Query
    typename__: Optional[Literal["CreateUserApiKeyMutationPayload"]] = Field(
        "CreateUserApiKeyMutationPayload", alias="__typename"
    )


class DataQualityTimeSeries(TimeSeries):
    model_config = ConfigDict(
        frozen=True,
    )
    data: list[TimeSeriesDataPoint]
    typename__: Optional[Literal["DataQualityTimeSeries"]] = Field(
        "DataQualityTimeSeries", alias="__typename"
    )


class Dataset(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime
    description: Optional[String] = None
    exampleCount: Int = Field(
        ...,
        description=(
            "Number of examples in a specific version if version is specified, or in"
            " the latest version if version is not specified."
        ),
    )
    examples: DatasetExampleConnection
    experimentAnnotationSummaries: list[ExperimentAnnotationSummary]
    experimentCount: Int = Field(
        ...,
        description=(
            "Number of experiments for a specific version if version is specified, or"
            " for all versions if version is not specified."
        ),
    )
    experiments: ExperimentConnection
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    lastUpdatedAt: Optional[DateTime] = None
    metadata: JSON
    name: String
    updatedAt: DateTime
    versions: DatasetVersionConnection
    typename__: Optional[Literal["Dataset"]] = Field("Dataset", alias="__typename")


class DatasetConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[DatasetEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["DatasetConnection"]] = Field(
        "DatasetConnection", alias="__typename"
    )


class DatasetEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: Dataset = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["DatasetEdge"]] = Field(
        "DatasetEdge", alias="__typename"
    )


class DatasetExample(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime
    experimentRuns: ExperimentRunConnection
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    revision: DatasetExampleRevision
    span: Optional[Span] = None
    typename__: Optional[Literal["DatasetExample"]] = Field(
        "DatasetExample", alias="__typename"
    )


class DatasetExampleConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[DatasetExampleEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["DatasetExampleConnection"]] = Field(
        "DatasetExampleConnection", alias="__typename"
    )


class DatasetExampleEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: DatasetExample = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["DatasetExampleEdge"]] = Field(
        "DatasetExampleEdge", alias="__typename"
    )


class DatasetExampleRevision(ExampleRevision):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime
    input: JSON
    metadata: JSON
    output: JSON
    revisionKind: RevisionKind
    typename__: Optional[Literal["DatasetExampleRevision"]] = Field(
        "DatasetExampleRevision", alias="__typename"
    )


class DatasetMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    dataset: Dataset
    typename__: Optional[Literal["DatasetMutationPayload"]] = Field(
        "DatasetMutationPayload", alias="__typename"
    )


class DatasetValues(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    primaryValue: Optional[Float] = None
    referenceValue: Optional[Float] = None
    typename__: Optional[Literal["DatasetValues"]] = Field(
        "DatasetValues", alias="__typename"
    )


class DatasetVersion(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime
    description: Optional[String] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    metadata: JSON
    typename__: Optional[Literal["DatasetVersion"]] = Field(
        "DatasetVersion", alias="__typename"
    )


class DatasetVersionConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[DatasetVersionEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["DatasetVersionConnection"]] = Field(
        "DatasetVersionConnection", alias="__typename"
    )


class DatasetVersionEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: DatasetVersion = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["DatasetVersionEdge"]] = Field(
        "DatasetVersionEdge", alias="__typename"
    )


class DbTableStats(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    numBytes: Float
    tableName: String
    typename__: Optional[Literal["DbTableStats"]] = Field(
        "DbTableStats", alias="__typename"
    )


class DeleteApiKeyMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    apiKeyId: GlobalID
    query: Query
    typename__: Optional[Literal["DeleteApiKeyMutationPayload"]] = Field(
        "DeleteApiKeyMutationPayload", alias="__typename"
    )


class DeletePromptMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    query: Query
    typename__: Optional[Literal["DeletePromptMutationPayload"]] = Field(
        "DeletePromptMutationPayload", alias="__typename"
    )


class Dimension(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    categories: list[String] = Field(
        ...,
        description=(
            "Returns the observed categories of a categorical dimension (usually a"
            " dimension of string values) as a list of unique string labels sorted in"
            " lexicographical order. Missing values are excluded. Non-categorical"
            " dimensions return an empty list."
        ),
    )
    dataQualityMetric: Optional[Float] = None
    dataQualityTimeSeries: DataQualityTimeSeries = Field(
        ...,
        description=(
            "Returns the time series of the specified metric for data within a time"
            " range. Data points are generated starting at the end time and are"
            " separated by the sampling interval. Each data point is labeled by the end"
            " instant and contains data from their respective evaluation windows."
        ),
    )
    dataType: DimensionDataType = Field(
        ..., description="The data type of the column. Categorical or numeric."
    )
    driftMetric: Optional[Float] = None
    driftTimeSeries: DriftTimeSeries = Field(
        ...,
        description=(
            "The time series of the specified metric for data within a time range. Data"
            " points are generated starting at the end time and are separated by the"
            " sampling interval. Each data point is labeled by the end instant and"
            " contains data from their respective evaluation windows."
        ),
    )
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    name: String = Field(
        ..., description="The name of the dimension (a.k.a. the column name)"
    )
    segmentsComparison: Segments = Field(
        ...,
        description=(
            "The segments across both inference sets and returns the counts per segment"
        ),
    )
    shape: DimensionShape = Field(
        ..., description="Whether the dimension data is continuous or discrete."
    )
    type: DimensionType = Field(
        ...,
        description=(
            "Whether the dimension represents a feature, tag, prediction, or actual."
        ),
    )
    typename__: Optional[Literal["Dimension"]] = Field("Dimension", alias="__typename")


class DimensionConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[DimensionEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["DimensionConnection"]] = Field(
        "DimensionConnection", alias="__typename"
    )


class DimensionEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: Dimension = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["DimensionEdge"]] = Field(
        "DimensionEdge", alias="__typename"
    )


class DimensionWithValue(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    dimension: Dimension
    value: Optional[String] = Field(
        default=None, description="The string representation of the dimension's value"
    )
    typename__: Optional[Literal["DimensionWithValue"]] = Field(
        "DimensionWithValue", alias="__typename"
    )


class DocumentEvaluation(Annotation):
    model_config = ConfigDict(
        frozen=True,
    )
    documentPosition: Int = Field(
        ...,
        description=(
            "The zero-based index among retrieved documents, which is collected as a"
            " list (even when ordering is not inherently meaningful)."
        ),
    )
    explanation: Optional[String] = Field(
        default=None,
        description=(
            "The annotator's explanation for the annotation result (i.e. score or"
            " label, or both) given to the subject."
        ),
    )
    label: Optional[String] = Field(
        default=None,
        description=(
            "Value of the annotation in the form of a string, e.g. 'helpful' or 'not"
            " helpful'. Note that the label is not necessarily binary."
        ),
    )
    name: String = Field(
        ..., description="Name of the annotation, e.g. 'helpfulness' or 'relevance'."
    )
    score: Optional[Float] = Field(
        default=None,
        description="Value of the annotation in the form of a numeric score.",
    )
    typename__: Optional[Literal["DocumentEvaluation"]] = Field(
        "DocumentEvaluation", alias="__typename"
    )


class DocumentEvaluationSummary(BaseModel):
    """
    Summarization of retrieval metrics: Average NDCG@K, Average Precision@K, Mean Reciprocal Rank, Hit Rate, etc.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    averageNdcg: Optional[Float] = None
    averagePrecision: Optional[Float] = None
    countHit: Int
    countNdcg: Int
    countPrecision: Int
    countReciprocalRank: Int
    evaluationName: String
    hitRate: Optional[Float] = None
    meanReciprocalRank: Optional[Float] = None
    typename__: Optional[Literal["DocumentEvaluationSummary"]] = Field(
        "DocumentEvaluationSummary", alias="__typename"
    )


class DocumentRetrievalMetrics(BaseModel):
    """
    A collection of retrieval metrics computed on a list of document evaluation scores: NDCG@K, Precision@K, Reciprocal Rank, etc.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    evaluationName: String
    hit: Optional[Float] = Field(
        default=None,
        description=(
            "Return 1.0 if any score is truthy (i.e. is a hit), e.g. score=1."
            " Otherwise, return `NaN` if any score is non-finite (e.g. `NaN`), or"
            " return 0.0 if all scores are falsy, e.g. all scores are 0."
        ),
    )
    ndcg: Optional[Float] = Field(
        default=None,
        description=(
            "Normalized Discounted Cumulative Gain (NDCG) at `k` with log base 2"
            " discounting. If `k` is None, it's set to the length of the scores. If `k`"
            " < 1, return 0.0."
        ),
    )
    precision: Optional[Float] = Field(
        default=None,
        description=(
            "Precision at `k`, defined as the fraction of truthy scores among first `k`"
            " positions (1-based index). If `k` is None, then it's set to the length of"
            " the scores. If `k` < 1, return 0.0."
        ),
    )
    reciprocalRank: Optional[Float] = Field(
        default=None,
        description=(
            "Return `1/R` where `R` is the rank of the first hit, i.e. the 1-based"
            " index position of first truthy score, e.g. score=1. If a non-finite value"
            " (e.g. `NaN`) is encountered before the first (finite) truthy score, then"
            " return `NaN`, otherwise if no truthy score is found (or if the count of"
            " scores is zero), return 0.0."
        ),
    )
    typename__: Optional[Literal["DocumentRetrievalMetrics"]] = Field(
        "DocumentRetrievalMetrics", alias="__typename"
    )


class DriftTimeSeries(TimeSeries):
    model_config = ConfigDict(
        frozen=True,
    )
    data: list[TimeSeriesDataPoint]
    typename__: Optional[Literal["DriftTimeSeries"]] = Field(
        "DriftTimeSeries", alias="__typename"
    )


class EmbeddingDimension(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    UMAPPoints: UMAPPoints
    dataQualityTimeSeries: DataQualityTimeSeries = Field(
        ...,
        description=(
            "Returns the time series of the specified metric for data within timeRange."
            " Data points are generated starting at the end time, are separated by the"
            " sampling interval. Each data point is labeled by the end instant of and"
            " contains data from their respective evaluation window."
        ),
    )
    driftMetric: Optional[Float] = Field(
        default=None,
        description=(
            "Computes a drift metric between all reference data and the primary data"
            " belonging to the input time range (inclusive of the time range start and"
            " exclusive of the time range end). Returns None if no reference dataset"
            " exists, if no primary data exists in the input time range, or if the"
            " input time range is invalid."
        ),
    )
    driftTimeSeries: DriftTimeSeries = Field(
        ...,
        description=(
            "Computes a drift time-series between the primary and reference datasets."
            " The output drift time-series contains one data point for each whole hour"
            " in the input time range (inclusive of the time range start and exclusive"
            " of the time range end). Each data point contains the drift metric value"
            " between all reference data and the primary data within the evaluation"
            " window ending at the corresponding time. Returns None if no reference"
            " dataset exists or if the input time range is invalid.           "
        ),
    )
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    name: String
    retrievalMetric: Optional[Float] = Field(
        default=None,
        description=(
            "Computes a retrieval metric between corpus data and the primary data"
            " belonging to the input time range (inclusive of the time range start and"
            " exclusive of the time range end). Returns None if no reference dataset"
            " exists, if no primary data exists in the input time range, or if the"
            " input time range is invalid."
        ),
    )
    retrievalMetricTimeSeries: DriftTimeSeries = Field(
        ...,
        description=(
            "Computes a retrieval metric between the primary and corpus datasets. The"
            " output time-series contains one data point for each whole hour in the"
            " input time range (inclusive of the time range start and exclusive of the"
            " time range end). Each data point contains the metric value between all"
            " corpus data and the primary data within the evaluation window ending at"
            " the corresponding time. Returns None if no corpus dataset exists or if"
            " the input time range is invalid.           "
        ),
    )
    typename__: Optional[Literal["EmbeddingDimension"]] = Field(
        "EmbeddingDimension", alias="__typename"
    )


class EmbeddingDimensionConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[EmbeddingDimensionEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["EmbeddingDimensionConnection"]] = Field(
        "EmbeddingDimensionConnection", alias="__typename"
    )


class EmbeddingDimensionEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: EmbeddingDimension = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["EmbeddingDimensionEdge"]] = Field(
        "EmbeddingDimensionEdge", alias="__typename"
    )


class EmbeddingMetadata(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    linkToData: Optional[String] = None
    predictionId: Optional[String] = None
    rawData: Optional[String] = None
    typename__: Optional[Literal["EmbeddingMetadata"]] = Field(
        "EmbeddingMetadata", alias="__typename"
    )


class Event(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    dimensions: list[DimensionWithValue]
    documentText: Optional[String] = Field(
        default=None,
        description=(
            "The text of the document if the event is a retrieved document record"
        ),
    )
    eventMetadata: EventMetadata
    id: ID
    promptAndResponse: Optional[PromptResponse] = Field(
        default=None,
        description="The prompt and response pair associated with the event",
    )
    typename__: Optional[Literal["Event"]] = Field("Event", alias="__typename")


class EventMetadata(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    actualLabel: Optional[String] = None
    actualScore: Optional[Float] = None
    predictionId: Optional[String] = None
    predictionLabel: Optional[String] = None
    predictionScore: Optional[Float] = None
    typename__: Optional[Literal["EventMetadata"]] = Field(
        "EventMetadata", alias="__typename"
    )


class Experiment(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    annotationSummaries: list[ExperimentAnnotationSummary]
    averageRunLatencyMs: Optional[Float] = None
    createdAt: DateTime
    description: Optional[String] = None
    errorRate: Optional[Float] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    lastUpdatedAt: Optional[DateTime] = None
    metadata: JSON
    name: String
    project: Optional[Project] = None
    projectName: Optional[String] = None
    runCount: Int
    runs: ExperimentRunConnection
    sequenceNumber: Int = Field(
        ...,
        description=(
            "Sequence number (1-based) of experiments belonging to the same dataset"
        ),
    )
    updatedAt: DateTime
    typename__: Optional[Literal["Experiment"]] = Field(
        "Experiment", alias="__typename"
    )


class ExperimentAnnotationSummary(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    annotationName: String
    count: Int
    errorCount: Int
    maxScore: Optional[Float] = None
    meanScore: Optional[Float] = None
    minScore: Optional[Float] = None
    typename__: Optional[Literal["ExperimentAnnotationSummary"]] = Field(
        "ExperimentAnnotationSummary", alias="__typename"
    )


class ExperimentComparison(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    example: DatasetExample
    runComparisonItems: list[RunComparisonItem]
    typename__: Optional[Literal["ExperimentComparison"]] = Field(
        "ExperimentComparison", alias="__typename"
    )


class ExperimentConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[ExperimentEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["ExperimentConnection"]] = Field(
        "ExperimentConnection", alias="__typename"
    )


class ExperimentEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: Experiment = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["ExperimentEdge"]] = Field(
        "ExperimentEdge", alias="__typename"
    )


class ExperimentMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    experiments: list[Experiment]
    typename__: Optional[Literal["ExperimentMutationPayload"]] = Field(
        "ExperimentMutationPayload", alias="__typename"
    )


class ExperimentRun(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    annotations: ExperimentRunAnnotationConnection
    endTime: DateTime
    error: Optional[String] = None
    example: DatasetExample
    experimentId: GlobalID
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    output: Optional[JSON] = None
    startTime: DateTime
    trace: Optional[Trace] = None
    traceId: Optional[String] = None
    typename__: Optional[Literal["ExperimentRun"]] = Field(
        "ExperimentRun", alias="__typename"
    )


class ExperimentRunAnnotation(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    annotatorKind: ExperimentRunAnnotatorKind
    endTime: DateTime
    error: Optional[String] = None
    explanation: Optional[String] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    label: Optional[String] = None
    metadata: JSON
    name: String
    score: Optional[Float] = None
    startTime: DateTime
    trace: Optional[Trace] = None
    traceId: Optional[String] = None
    typename__: Optional[Literal["ExperimentRunAnnotation"]] = Field(
        "ExperimentRunAnnotation", alias="__typename"
    )


class ExperimentRunAnnotationConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[ExperimentRunAnnotationEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["ExperimentRunAnnotationConnection"]] = Field(
        "ExperimentRunAnnotationConnection", alias="__typename"
    )


class ExperimentRunAnnotationEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: ExperimentRunAnnotation = Field(
        ..., description="The item at the end of the edge"
    )
    typename__: Optional[Literal["ExperimentRunAnnotationEdge"]] = Field(
        "ExperimentRunAnnotationEdge", alias="__typename"
    )


class ExperimentRunConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[ExperimentRunEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["ExperimentRunConnection"]] = Field(
        "ExperimentRunConnection", alias="__typename"
    )


class ExperimentRunEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: ExperimentRun = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["ExperimentRunEdge"]] = Field(
        "ExperimentRunEdge", alias="__typename"
    )


class ExportedFile(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    fileName: String = Field(..., description="File name without the file extension.")
    typename__: Optional[Literal["ExportedFile"]] = Field(
        "ExportedFile", alias="__typename"
    )


class FloatInvocationParameter(InvocationParameterBase):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    defaultValue: Optional[Float] = None
    invocationInputField: InvocationInputField
    invocationName: String
    label: String
    required: Boolean
    typename__: Optional[Literal["FloatInvocationParameter"]] = Field(
        "FloatInvocationParameter", alias="__typename"
    )


class FunctionCallChunk(ChatCompletionSubscriptionPayload):
    model_config = ConfigDict(
        frozen=True,
    )
    arguments: String
    datasetExampleId: Optional[GlobalID] = None
    name: String
    typename__: Optional[Literal["FunctionCallChunk"]] = Field(
        "FunctionCallChunk", alias="__typename"
    )


class Functionality(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    modelInferences: Boolean = Field(
        ..., description="Model inferences are available for analysis"
    )
    tracing: Boolean = Field(
        ..., description="Generative tracing records are available for analysis"
    )
    typename__: Optional[Literal["Functionality"]] = Field(
        "Functionality", alias="__typename"
    )


class GenerativeModel(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: String
    providerKey: GenerativeProviderKey
    typename__: Optional[Literal["GenerativeModel"]] = Field(
        "GenerativeModel", alias="__typename"
    )


class GenerativeProvider(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    apiKeyEnvVar: String = Field(..., description="The API key for the provider")
    apiKeySet: Boolean = Field(
        ...,
        description="Whether the credentials are set on the server for the provider",
    )
    dependencies: list[String]
    dependenciesInstalled: Boolean
    key: GenerativeProviderKey
    name: String
    typename__: Optional[Literal["GenerativeProvider"]] = Field(
        "GenerativeProvider", alias="__typename"
    )


class Inferences(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    endTime: DateTime = Field(..., description="The end bookend of the data")
    events: list[Event]
    name: String = Field(
        ..., description="Returns a human friendly name for the inferences."
    )
    recordCount: Int = Field(..., description="The record count of the data")
    startTime: DateTime = Field(..., description="The start bookend of the data")
    typename__: Optional[Literal["Inferences"]] = Field(
        "Inferences", alias="__typename"
    )


class IntInvocationParameter(InvocationParameterBase):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    defaultValue: Optional[Int] = None
    invocationInputField: InvocationInputField
    invocationName: String
    label: String
    required: Boolean
    typename__: Optional[Literal["IntInvocationParameter"]] = Field(
        "IntInvocationParameter", alias="__typename"
    )


class IntervalBin(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    range: NumericRange
    typename__: Optional[Literal["IntervalBin"]] = Field(
        "IntervalBin", alias="__typename"
    )


class JSONInvocationParameter(InvocationParameterBase):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    defaultValue: Optional[JSON] = None
    invocationInputField: InvocationInputField
    invocationName: String
    label: String
    required: Boolean
    typename__: Optional[Literal["JSONInvocationParameter"]] = Field(
        "JSONInvocationParameter", alias="__typename"
    )


class LabelFraction(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    fraction: Float
    label: String
    typename__: Optional[Literal["LabelFraction"]] = Field(
        "LabelFraction", alias="__typename"
    )


class MissingValueBin(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: Optional[String] = None
    typename__: Optional[Literal["MissingValueBin"]] = Field(
        "MissingValueBin", alias="__typename"
    )


class Model(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    corpusInferences: Optional[Inferences] = None
    dimensions: DimensionConnection
    embeddingDimensions: EmbeddingDimensionConnection
    exportedFiles: list[ExportedFile] = Field(
        ...,
        description=(
            "Returns exported file names sorted by descending modification time."
        ),
    )
    performanceMetric: Optional[Float] = None
    performanceTimeSeries: PerformanceTimeSeries = Field(
        ...,
        description=(
            "Returns the time series of the specified metric for data within a time"
            " range. Data points are generated starting at the end time and are"
            " separated by the sampling interval. Each data point is labeled by the end"
            " instant and contains data from their respective evaluation windows."
        ),
    )
    primaryInferences: Inferences
    referenceInferences: Optional[Inferences] = None
    typename__: Optional[Literal["Model"]] = Field("Model", alias="__typename")


class NominalBin(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: String
    typename__: Optional[Literal["NominalBin"]] = Field(
        "NominalBin", alias="__typename"
    )


class NumericRange(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    end: Float
    start: Float
    typename__: Optional[Literal["NumericRange"]] = Field(
        "NumericRange", alias="__typename"
    )


class PageInfo(BaseModel):
    """
    Information to aid in pagination.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    endCursor: Optional[String] = Field(
        default=None, description="When paginating forwards, the cursor to continue."
    )
    hasNextPage: Boolean = Field(
        ..., description="When paginating forwards, are there more items?"
    )
    hasPreviousPage: Boolean = Field(
        ..., description="When paginating backwards, are there more items?"
    )
    startCursor: Optional[String] = Field(
        default=None, description="When paginating backwards, the cursor to continue."
    )
    typename__: Optional[Literal["PageInfo"]] = Field("PageInfo", alias="__typename")


class PerformanceTimeSeries(TimeSeries):
    model_config = ConfigDict(
        frozen=True,
    )
    data: list[TimeSeriesDataPoint]
    typename__: Optional[Literal["PerformanceTimeSeries"]] = Field(
        "PerformanceTimeSeries", alias="__typename"
    )


class Point2D(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    x: Float
    y: Float
    typename__: Optional[Literal["Point2D"]] = Field("Point2D", alias="__typename")


class Point3D(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    x: Float
    y: Float
    z: Float
    typename__: Optional[Literal["Point3D"]] = Field("Point3D", alias="__typename")


class Project(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    documentEvaluationNames: list[String] = Field(
        ..., description="Names of available document evaluations."
    )
    documentEvaluationSummary: Optional[DocumentEvaluationSummary] = None
    endTime: Optional[DateTime] = None
    gradientEndColor: String
    gradientStartColor: String
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    latencyMsQuantile: Optional[Float] = None
    name: String
    recordCount: Int
    sessions: ProjectSessionConnection
    spanAnnotationNames: list[String] = Field(
        ...,
        description=(
            "Names of all available annotations for spans. (The list contains no"
            " duplicates.)"
        ),
    )
    spanAnnotationSummary: Optional[AnnotationSummary] = None
    spanLatencyMsQuantile: Optional[Float] = None
    spans: SpanConnection
    startTime: Optional[DateTime] = None
    streamingLastUpdatedAt: Optional[DateTime] = None
    tokenCountCompletion: Int
    tokenCountPrompt: Int
    tokenCountTotal: Int
    trace: Optional[Trace] = None
    traceAnnotationSummary: Optional[AnnotationSummary] = None
    traceAnnotationsNames: list[String] = Field(
        ...,
        description=(
            "Names of all available annotations for traces. (The list contains no"
            " duplicates.)"
        ),
    )
    traceCount: Int
    validateSpanFilterCondition: ValidationResult
    typename__: Optional[Literal["Project"]] = Field("Project", alias="__typename")


class ProjectConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[ProjectEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["ProjectConnection"]] = Field(
        "ProjectConnection", alias="__typename"
    )


class ProjectEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: Project = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["ProjectEdge"]] = Field(
        "ProjectEdge", alias="__typename"
    )


class ProjectSession(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    endTime: DateTime
    firstInput: Optional[SpanIOValue] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    lastOutput: Optional[SpanIOValue] = None
    numTraces: Int
    numTracesWithError: Int
    projectId: GlobalID
    sessionId: String
    startTime: DateTime
    tokenUsage: TokenUsage
    traceLatencyMsQuantile: Optional[Float] = None
    traces: TraceConnection
    typename__: Optional[Literal["ProjectSession"]] = Field(
        "ProjectSession", alias="__typename"
    )


class ProjectSessionConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[ProjectSessionEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["ProjectSessionConnection"]] = Field(
        "ProjectSessionConnection", alias="__typename"
    )


class ProjectSessionEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: ProjectSession = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["ProjectSessionEdge"]] = Field(
        "ProjectSessionEdge", alias="__typename"
    )


class Prompt(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime
    description: Optional[String] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    name: Identifier
    promptVersions: PromptVersionConnection
    sourcePrompt: Optional[Prompt] = None
    sourcePromptId: Optional[GlobalID] = None
    version: PromptVersion
    versionTags: list[PromptVersionTag]
    typename__: Optional[Literal["Prompt"]] = Field("Prompt", alias="__typename")


class PromptChatTemplate(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    messages: list[PromptMessage]
    typename__: Optional[Literal["PromptChatTemplate"]] = Field(
        "PromptChatTemplate", alias="__typename"
    )


class PromptConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[PromptEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["PromptConnection"]] = Field(
        "PromptConnection", alias="__typename"
    )


class PromptEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: Prompt = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["PromptEdge"]] = Field(
        "PromptEdge", alias="__typename"
    )


class PromptLabel(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    name: Identifier
    prompts: list[Prompt]
    typename__: Optional[Literal["PromptLabel"]] = Field(
        "PromptLabel", alias="__typename"
    )


class PromptLabelConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[PromptLabelEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["PromptLabelConnection"]] = Field(
        "PromptLabelConnection", alias="__typename"
    )


class PromptLabelEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: PromptLabel = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["PromptLabelEdge"]] = Field(
        "PromptLabelEdge", alias="__typename"
    )


class PromptLabelMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    promptLabel: Optional[PromptLabel] = None
    query: Query
    typename__: Optional[Literal["PromptLabelMutationPayload"]] = Field(
        "PromptLabelMutationPayload", alias="__typename"
    )


class PromptMessage(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    content: list[ContentPart]
    role: PromptMessageRole
    typename__: Optional[Literal["PromptMessage"]] = Field(
        "PromptMessage", alias="__typename"
    )


class PromptResponse(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    prompt: Optional[String] = Field(
        default=None, description="The prompt submitted to the LLM"
    )
    response: Optional[String] = Field(
        default=None, description="The response generated by the LLM"
    )
    typename__: Optional[Literal["PromptResponse"]] = Field(
        "PromptResponse", alias="__typename"
    )


class PromptStringTemplate(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    template: String
    typename__: Optional[Literal["PromptStringTemplate"]] = Field(
        "PromptStringTemplate", alias="__typename"
    )


class PromptVersion(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime
    description: Optional[String] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    invocationParameters: Optional[JSON] = None
    metadata: JSON
    modelName: String
    modelProvider: ModelProvider
    previousVersion: Optional[PromptVersion] = None
    responseFormat: Optional[ResponseFormat] = None
    sequenceNumber: Int = Field(
        ...,
        description=(
            "Sequence number (1-based) of prompt versions belonging to the same prompt"
        ),
    )
    tags: list[PromptVersionTag]
    template: PromptTemplate
    templateFormat: PromptTemplateFormat
    templateType: PromptTemplateType
    tools: list[ToolDefinition]
    user: Optional[User] = None
    typename__: Optional[Literal["PromptVersion"]] = Field(
        "PromptVersion", alias="__typename"
    )


class PromptVersionConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[PromptVersionEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["PromptVersionConnection"]] = Field(
        "PromptVersionConnection", alias="__typename"
    )


class PromptVersionEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: PromptVersion = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["PromptVersionEdge"]] = Field(
        "PromptVersionEdge", alias="__typename"
    )


class PromptVersionTag(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    name: Identifier
    promptVersionId: GlobalID
    typename__: Optional[Literal["PromptVersionTag"]] = Field(
        "PromptVersionTag", alias="__typename"
    )


class PromptVersionTagMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    prompt: Prompt
    promptVersionTag: Optional[PromptVersionTag] = None
    query: Query
    typename__: Optional[Literal["PromptVersionTagMutationPayload"]] = Field(
        "PromptVersionTagMutationPayload", alias="__typename"
    )


class ResponseFormat(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    definition: JSON
    typename__: Optional[Literal["ResponseFormat"]] = Field(
        "ResponseFormat", alias="__typename"
    )


class Retrieval(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    documentId: ID
    queryId: ID
    relevance: Optional[Float] = None
    typename__: Optional[Literal["Retrieval"]] = Field("Retrieval", alias="__typename")


class RunComparisonItem(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    experimentId: GlobalID
    runs: list[ExperimentRun]
    typename__: Optional[Literal["RunComparisonItem"]] = Field(
        "RunComparisonItem", alias="__typename"
    )


class Segment(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    bin: Bin
    counts: DatasetValues
    typename__: Optional[Literal["Segment"]] = Field("Segment", alias="__typename")


class Segments(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    segments: list[Segment]
    totalCounts: DatasetValues
    typename__: Optional[Literal["Segments"]] = Field("Segments", alias="__typename")


class Span(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    asExampleRevision: SpanAsExampleRevision = Field(
        ...,
        description=(
            "The span's attributes translated into an example revision for a dataset"
        ),
    )
    attributes: String = Field(..., description="Span attributes as a JSON string")
    containedInDataset: Boolean = Field(
        ..., description="Indicates if the span is contained in any dataset"
    )
    context: SpanContext
    cumulativeTokenCountCompletion: Optional[Int] = Field(
        default=None,
        description=(
            "Cumulative (completion) token count from self and all descendant spans"
            " (children, grandchildren, etc.)"
        ),
    )
    cumulativeTokenCountPrompt: Optional[Int] = Field(
        default=None,
        description=(
            "Cumulative (prompt) token count from self and all descendant spans"
            " (children, grandchildren, etc.)"
        ),
    )
    cumulativeTokenCountTotal: Optional[Int] = Field(
        default=None,
        description=(
            "Cumulative (prompt plus completion) token count from self and all"
            " descendant spans (children, grandchildren, etc.)"
        ),
    )
    descendants: SpanConnection = Field(
        ..., description="All descendant spans (children, grandchildren, etc.)"
    )
    documentEvaluations: list[DocumentEvaluation] = Field(
        ...,
        description=(
            "Evaluations of the documents associated with the span, e.g. if the span is"
            " a RETRIEVER with a list of documents in its RETRIEVAL_DOCUMENTS"
            " attribute, an evaluation for each document may assess its relevance"
            " respect to the input query of the span. Note that RETRIEVAL_DOCUMENTS is"
            " a list, and each evaluation is identified by its document's (zero-based)"
            " index in that list."
        ),
    )
    documentRetrievalMetrics: list[DocumentRetrievalMetrics] = Field(
        ..., description="Retrieval metrics: NDCG@K, Precision@K, Reciprocal Rank, etc."
    )
    endTime: Optional[DateTime] = None
    events: list[SpanEvent]
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    input: Optional[SpanIOValue] = None
    invocationParameters: list[InvocationParameter] = Field(
        ..., description="Invocation parameters for the span"
    )
    latencyMs: Optional[Float] = None
    metadata: Optional[String] = Field(
        default=None, description="Metadata as a JSON string"
    )
    name: String
    numChildSpans: Int
    numDocuments: Optional[Int] = None
    output: Optional[SpanIOValue] = None
    parentId: Optional[ID] = Field(
        default=None, description="the parent span ID. If null, it is a root span"
    )
    project: Project = Field(..., description="The project that this span belongs to.")
    propagatedStatusCode: SpanStatusCode = Field(
        ...,
        description=(
            "Propagated status code that percolates up error status codes from"
            " descendant spans (children, grandchildren, etc.)"
        ),
    )
    spanAnnotations: list[SpanAnnotation] = Field(
        ...,
        description=(
            "Annotations associated with the span. This encompasses both LLM and human"
            " annotations."
        ),
    )
    spanId: ID
    spanKind: SpanKind
    startTime: DateTime
    statusCode: SpanStatusCode
    statusMessage: String
    tokenCountCompletion: Optional[Int] = None
    tokenCountPrompt: Optional[Int] = None
    tokenCountTotal: Optional[Int] = None
    trace: Trace
    typename__: Optional[Literal["Span"]] = Field("Span", alias="__typename")


class SpanAnnotation(Annotation, Node):
    model_config = ConfigDict(
        frozen=True,
    )
    annotatorKind: AnnotatorKind
    explanation: Optional[String] = Field(
        default=None,
        description=(
            "The annotator's explanation for the annotation result (i.e. score or"
            " label, or both) given to the subject."
        ),
    )
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    label: Optional[String] = Field(
        default=None,
        description=(
            "Value of the annotation in the form of a string, e.g. 'helpful' or 'not"
            " helpful'. Note that the label is not necessarily binary."
        ),
    )
    metadata: JSON
    name: String = Field(
        ..., description="Name of the annotation, e.g. 'helpfulness' or 'relevance'."
    )
    score: Optional[Float] = Field(
        default=None,
        description="Value of the annotation in the form of a numeric score.",
    )
    spanId: GlobalID
    typename__: Optional[Literal["SpanAnnotation"]] = Field(
        "SpanAnnotation", alias="__typename"
    )


class SpanAnnotationMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    query: Query
    spanAnnotations: list[SpanAnnotation]
    typename__: Optional[Literal["SpanAnnotationMutationPayload"]] = Field(
        "SpanAnnotationMutationPayload", alias="__typename"
    )


class SpanAsExampleRevision(ExampleRevision):
    model_config = ConfigDict(
        frozen=True,
    )
    input: JSON
    metadata: JSON
    output: JSON
    typename__: Optional[Literal["SpanAsExampleRevision"]] = Field(
        "SpanAsExampleRevision", alias="__typename"
    )


class SpanConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[SpanEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["SpanConnection"]] = Field(
        "SpanConnection", alias="__typename"
    )


class SpanContext(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    spanId: ID
    traceId: ID
    typename__: Optional[Literal["SpanContext"]] = Field(
        "SpanContext", alias="__typename"
    )


class SpanEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: Span = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["SpanEdge"]] = Field("SpanEdge", alias="__typename")


class SpanEvent(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    message: String
    name: String
    timestamp: DateTime
    typename__: Optional[Literal["SpanEvent"]] = Field("SpanEvent", alias="__typename")


class SpanIOValue(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    mimeType: MimeType
    truncatedValue: String = Field(
        ...,
        description=(
            "Truncated value up to 100 characters, appending '...' if truncated."
        ),
    )
    value: String
    typename__: Optional[Literal["SpanIOValue"]] = Field(
        "SpanIOValue", alias="__typename"
    )


class StringInvocationParameter(InvocationParameterBase):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    defaultValue: Optional[String] = None
    invocationInputField: InvocationInputField
    invocationName: String
    label: String
    required: Boolean
    typename__: Optional[Literal["StringInvocationParameter"]] = Field(
        "StringInvocationParameter", alias="__typename"
    )


class StringListInvocationParameter(InvocationParameterBase):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    defaultValue: Optional[list[String]] = None
    invocationInputField: InvocationInputField
    invocationName: String
    label: String
    required: Boolean
    typename__: Optional[Literal["StringListInvocationParameter"]] = Field(
        "StringListInvocationParameter", alias="__typename"
    )


class Subscription(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    chatCompletion: ChatCompletionSubscriptionPayload
    chatCompletionOverDataset: ChatCompletionSubscriptionPayload
    typename__: Optional[Literal["Subscription"]] = Field(
        "Subscription", alias="__typename"
    )


class SystemApiKey(ApiKey, Node):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime = Field(
        ..., description="The date and time the API key was created."
    )
    description: Optional[String] = Field(
        default=None, description="Description of the API key."
    )
    expiresAt: Optional[DateTime] = Field(
        default=None, description="The date and time the API key will expire."
    )
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    name: String = Field(..., description="Name of the API key.")
    typename__: Optional[Literal["SystemApiKey"]] = Field(
        "SystemApiKey", alias="__typename"
    )


class TextChunk(ChatCompletionSubscriptionPayload):
    model_config = ConfigDict(
        frozen=True,
    )
    content: String
    datasetExampleId: Optional[GlobalID] = None
    typename__: Optional[Literal["TextChunk"]] = Field("TextChunk", alias="__typename")


class TextContentPart(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    text: TextContentValue
    typename__: Optional[Literal["TextContentPart"]] = Field(
        "TextContentPart", alias="__typename"
    )


class TextContentValue(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    text: String
    typename__: Optional[Literal["TextContentValue"]] = Field(
        "TextContentValue", alias="__typename"
    )


class TimeSeriesDataPoint(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    timestamp: DateTime
    value: Optional[Float] = None
    typename__: Optional[Literal["TimeSeriesDataPoint"]] = Field(
        "TimeSeriesDataPoint", alias="__typename"
    )


class TokenUsage(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    completion: Int
    prompt: Int
    total: Int
    typename__: Optional[Literal["TokenUsage"]] = Field(
        "TokenUsage", alias="__typename"
    )


class ToolCallChunk(ChatCompletionSubscriptionPayload):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetExampleId: Optional[GlobalID] = None
    function: FunctionCallChunk
    id: String
    typename__: Optional[Literal["ToolCallChunk"]] = Field(
        "ToolCallChunk", alias="__typename"
    )


class ToolCallContentPart(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    toolCall: ToolCallContentValue
    typename__: Optional[Literal["ToolCallContentPart"]] = Field(
        "ToolCallContentPart", alias="__typename"
    )


class ToolCallContentValue(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    toolCall: ToolCallFunction
    toolCallId: String
    typename__: Optional[Literal["ToolCallContentValue"]] = Field(
        "ToolCallContentValue", alias="__typename"
    )


class ToolCallFunction(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    arguments: String
    name: String
    typename__: Optional[Literal["ToolCallFunction"]] = Field(
        "ToolCallFunction", alias="__typename"
    )


class ToolDefinition(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    definition: JSON
    typename__: Optional[Literal["ToolDefinition"]] = Field(
        "ToolDefinition", alias="__typename"
    )


class ToolResultContentPart(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    toolResult: ToolResultContentValue
    typename__: Optional[Literal["ToolResultContentPart"]] = Field(
        "ToolResultContentPart", alias="__typename"
    )


class ToolResultContentValue(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    result: JSON
    toolCallId: String
    typename__: Optional[Literal["ToolResultContentValue"]] = Field(
        "ToolResultContentValue", alias="__typename"
    )


class Trace(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    endTime: DateTime
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    latencyMs: Optional[Float] = None
    numSpans: Int
    project: Project
    projectId: GlobalID
    projectSessionId: Optional[GlobalID] = None
    rootSpan: Optional[Span] = None
    session: Optional[ProjectSession] = None
    spanAnnotations: list[TraceAnnotation] = Field(
        ..., description="Annotations associated with the trace."
    )
    spans: SpanConnection
    startTime: DateTime
    traceId: ID
    typename__: Optional[Literal["Trace"]] = Field("Trace", alias="__typename")


class TraceAnnotation(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    annotatorKind: AnnotatorKind
    explanation: Optional[String] = None
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    label: Optional[String] = None
    metadata: JSON
    name: String
    score: Optional[Float] = None
    traceId: GlobalID
    typename__: Optional[Literal["TraceAnnotation"]] = Field(
        "TraceAnnotation", alias="__typename"
    )


class TraceAnnotationMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    query: Query
    traceAnnotations: list[TraceAnnotation]
    typename__: Optional[Literal["TraceAnnotationMutationPayload"]] = Field(
        "TraceAnnotationMutationPayload", alias="__typename"
    )


class TraceConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[TraceEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["TraceConnection"]] = Field(
        "TraceConnection", alias="__typename"
    )


class TraceEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: Trace = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["TraceEdge"]] = Field("TraceEdge", alias="__typename")


class UMAPPoint(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    coordinates: Point2DPoint3D
    embeddingMetadata: EmbeddingMetadata
    eventId: ID = Field(
        ..., description="The ID of the event that the point is a projection of"
    )
    eventMetadata: EventMetadata
    id: GlobalID
    typename__: Optional[Literal["UMAPPoint"]] = Field("UMAPPoint", alias="__typename")


class UMAPPoints(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    clusters: list[Cluster]
    contextRetrievals: list[Retrieval]
    corpusData: list[UMAPPoint]
    data: list[UMAPPoint]
    referenceData: list[UMAPPoint]
    typename__: Optional[Literal["UMAPPoints"]] = Field(
        "UMAPPoints", alias="__typename"
    )


class User(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    apiKeys: list[UserApiKey]
    authMethod: AuthMethod
    createdAt: DateTime
    email: String
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    passwordNeedsReset: Boolean
    profilePictureUrl: Optional[String] = None
    role: UserRole
    username: String
    typename__: Optional[Literal["User"]] = Field("User", alias="__typename")


class UserApiKey(ApiKey, Node):
    model_config = ConfigDict(
        frozen=True,
    )
    createdAt: DateTime = Field(
        ..., description="The date and time the API key was created."
    )
    description: Optional[String] = Field(
        default=None, description="Description of the API key."
    )
    expiresAt: Optional[DateTime] = Field(
        default=None, description="The date and time the API key will expire."
    )
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    name: String = Field(..., description="Name of the API key.")
    user: User
    typename__: Optional[Literal["UserApiKey"]] = Field(
        "UserApiKey", alias="__typename"
    )


class UserConnection(BaseModel):
    """
    A connection to a list of items.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    edges: list[UserEdge] = Field(
        ..., description="Contains the nodes in this connection"
    )
    pageInfo: PageInfo = Field(..., description="Pagination data for this connection")
    typename__: Optional[Literal["UserConnection"]] = Field(
        "UserConnection", alias="__typename"
    )


class UserEdge(BaseModel):
    """
    An edge in a connection.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    cursor: String = Field(..., description="A cursor for use in pagination")
    node: User = Field(..., description="The item at the end of the edge")
    typename__: Optional[Literal["UserEdge"]] = Field("UserEdge", alias="__typename")


class UserMutationPayload(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    user: User
    typename__: Optional[Literal["UserMutationPayload"]] = Field(
        "UserMutationPayload", alias="__typename"
    )


class UserRole(Node):
    model_config = ConfigDict(
        frozen=True,
    )
    id: GlobalID = Field(..., description="The Globally Unique ID of this object")
    name: String
    typename__: Optional[Literal["UserRole"]] = Field("UserRole", alias="__typename")


class ValidationResult(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    errorMessage: Optional[String] = None
    isValid: Boolean
    typename__: Optional[Literal["ValidationResult"]] = Field(
        "ValidationResult", alias="__typename"
    )


class AddExamplesToDatasetInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetId: GlobalID
    datasetVersionDescription: Optional[String] = None
    datasetVersionMetadata: Optional[JSON] = None
    examples: list[DatasetExampleInput]
    typename__: Optional[Literal["AddExamplesToDatasetInput"]] = Field(
        "AddExamplesToDatasetInput", alias="__typename"
    )


class AddSpansToDatasetInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetId: GlobalID
    datasetVersionDescription: Optional[String] = None
    datasetVersionMetadata: Optional[JSON] = None
    spanIds: list[GlobalID]
    typename__: Optional[Literal["AddSpansToDatasetInput"]] = Field(
        "AddSpansToDatasetInput", alias="__typename"
    )


class ChatCompletionInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    apiKey: Optional[String] = None
    invocationParameters: list[InvocationParameterInput]
    messages: list[ChatCompletionMessageInput]
    model: GenerativeModelInput
    promptName: Optional[Identifier] = None
    template: Optional[PromptTemplateOptions] = None
    tools: Optional[list[JSON]] = None
    typename__: Optional[Literal["ChatCompletionInput"]] = Field(
        "ChatCompletionInput", alias="__typename"
    )


class ChatCompletionMessageInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    content: JSON = Field(
        ...,
        description=(
            "The content of the message as JSON to support various kinds of text"
        ),
    )
    role: ChatCompletionMessageRole
    toolCallId: Optional[String] = Field(
        default=None,
        description=(
            "The ID that corresponds to a prior tool call. Used to link a tool message"
            " to a pre-existing tool call."
        ),
    )
    toolCalls: Optional[list[JSON]] = Field(
        default=None, description="The tool calls that were made in the message"
    )
    typename__: Optional[Literal["ChatCompletionMessageInput"]] = Field(
        "ChatCompletionMessageInput", alias="__typename"
    )


class ChatCompletionOverDatasetInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    apiKey: Optional[String] = None
    datasetId: GlobalID
    datasetVersionId: Optional[GlobalID] = None
    experimentDescription: Optional[String] = None
    experimentMetadata: Optional[JSON] = {}
    experimentName: Optional[String] = None
    invocationParameters: list[InvocationParameterInput]
    messages: list[ChatCompletionMessageInput]
    model: GenerativeModelInput
    promptName: Optional[Identifier] = None
    templateFormat: PromptTemplateFormat
    tools: Optional[list[JSON]] = None
    typename__: Optional[Literal["ChatCompletionOverDatasetInput"]] = Field(
        "ChatCompletionOverDatasetInput", alias="__typename"
    )


class ChatPromptVersionInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    invocationParameters: JSON
    modelName: String
    modelProvider: ModelProvider
    responseFormat: Optional[ResponseFormatInput] = None
    template: PromptChatTemplateInput
    templateFormat: PromptTemplateFormat
    tools: list[ToolDefinitionInput]
    typename__: Optional[Literal["ChatPromptVersionInput"]] = Field(
        "ChatPromptVersionInput", alias="__typename"
    )


class ClearProjectInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    endTime: Optional[DateTime] = Field(
        default=None,
        description=(
            "The time up to which to purge data. Time is right-open /non-inclusive."
        ),
    )
    id: GlobalID
    typename__: Optional[Literal["ClearProjectInput"]] = Field(
        "ClearProjectInput", alias="__typename"
    )


class ClonePromptInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    name: Identifier
    promptId: GlobalID
    typename__: Optional[Literal["ClonePromptInput"]] = Field(
        "ClonePromptInput", alias="__typename"
    )


class ClusterInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    eventIds: list[ID]
    id: Optional[ID] = None
    typename__: Optional[Literal["ClusterInput"]] = Field(
        "ClusterInput", alias="__typename"
    )


class ContentPartInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    text: Optional[TextContentValueInput] = None
    toolCall: Optional[ToolCallContentValueInput] = None
    toolResult: Optional[ToolResultContentValueInput] = None
    typename__: Optional[Literal["ContentPartInput"]] = Field(
        "ContentPartInput", alias="__typename"
    )


class CreateApiKeyInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    expiresAt: Optional[DateTime] = None
    name: String
    typename__: Optional[Literal["CreateApiKeyInput"]] = Field(
        "CreateApiKeyInput", alias="__typename"
    )


class CreateChatPromptInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    name: Identifier
    promptVersion: ChatPromptVersionInput
    typename__: Optional[Literal["CreateChatPromptInput"]] = Field(
        "CreateChatPromptInput", alias="__typename"
    )


class CreateChatPromptVersionInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    promptId: GlobalID
    promptVersion: ChatPromptVersionInput
    tags: Optional[list[SetPromptVersionTagInput]] = None
    typename__: Optional[Literal["CreateChatPromptVersionInput"]] = Field(
        "CreateChatPromptVersionInput", alias="__typename"
    )


class CreateDatasetInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    metadata: Optional[JSON] = None
    name: String
    typename__: Optional[Literal["CreateDatasetInput"]] = Field(
        "CreateDatasetInput", alias="__typename"
    )


class CreatePromptLabelInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    name: Identifier
    typename__: Optional[Literal["CreatePromptLabelInput"]] = Field(
        "CreatePromptLabelInput", alias="__typename"
    )


class CreateSpanAnnotationInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    annotatorKind: AnnotatorKind
    explanation: Optional[String] = None
    label: Optional[String] = None
    metadata: JSON
    name: String
    score: Optional[Float] = None
    spanId: GlobalID
    typename__: Optional[Literal["CreateSpanAnnotationInput"]] = Field(
        "CreateSpanAnnotationInput", alias="__typename"
    )


class CreateTraceAnnotationInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    annotatorKind: AnnotatorKind
    explanation: Optional[String] = None
    label: Optional[String] = None
    metadata: JSON
    name: String
    score: Optional[Float] = None
    traceId: GlobalID
    typename__: Optional[Literal["CreateTraceAnnotationInput"]] = Field(
        "CreateTraceAnnotationInput", alias="__typename"
    )


class CreateUserApiKeyInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    expiresAt: Optional[DateTime] = None
    name: String
    typename__: Optional[Literal["CreateUserApiKeyInput"]] = Field(
        "CreateUserApiKeyInput", alias="__typename"
    )


class CreateUserInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    email: String
    password: String
    role: UserRoleInput
    username: String
    typename__: Optional[Literal["CreateUserInput"]] = Field(
        "CreateUserInput", alias="__typename"
    )


class DataQualityMetricInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    columnName: Optional[String] = None
    metric: DataQualityMetric
    typename__: Optional[Literal["DataQualityMetricInput"]] = Field(
        "DataQualityMetricInput", alias="__typename"
    )


class DatasetExampleInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    input: JSON
    metadata: JSON
    output: JSON
    spanId: Optional[GlobalID] = None
    typename__: Optional[Literal["DatasetExampleInput"]] = Field(
        "DatasetExampleInput", alias="__typename"
    )


class DatasetExamplePatch(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    exampleId: GlobalID
    input: Optional[JSON] = None
    metadata: Optional[JSON] = None
    output: Optional[JSON] = None
    typename__: Optional[Literal["DatasetExamplePatch"]] = Field(
        "DatasetExamplePatch", alias="__typename"
    )


class DatasetSort(BaseModel):
    """
    The sort key and direction for dataset connections
    """

    model_config = ConfigDict(
        frozen=True,
    )
    col: DatasetColumn
    dir: SortDir
    typename__: Optional[Literal["DatasetSort"]] = Field(
        "DatasetSort", alias="__typename"
    )


class DatasetVersionSort(BaseModel):
    """
    The sort key and direction for dataset version connections
    """

    model_config = ConfigDict(
        frozen=True,
    )
    col: DatasetVersionColumn
    dir: SortDir
    typename__: Optional[Literal["DatasetVersionSort"]] = Field(
        "DatasetVersionSort", alias="__typename"
    )


class DeleteAnnotationsInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    annotationIds: list[GlobalID]
    typename__: Optional[Literal["DeleteAnnotationsInput"]] = Field(
        "DeleteAnnotationsInput", alias="__typename"
    )


class DeleteApiKeyInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: GlobalID
    typename__: Optional[Literal["DeleteApiKeyInput"]] = Field(
        "DeleteApiKeyInput", alias="__typename"
    )


class DeleteDatasetExamplesInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetVersionDescription: Optional[String] = None
    datasetVersionMetadata: Optional[JSON] = None
    exampleIds: list[GlobalID]
    typename__: Optional[Literal["DeleteDatasetExamplesInput"]] = Field(
        "DeleteDatasetExamplesInput", alias="__typename"
    )


class DeleteDatasetInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetId: GlobalID
    typename__: Optional[Literal["DeleteDatasetInput"]] = Field(
        "DeleteDatasetInput", alias="__typename"
    )


class DeleteExperimentsInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    experimentIds: list[GlobalID]
    typename__: Optional[Literal["DeleteExperimentsInput"]] = Field(
        "DeleteExperimentsInput", alias="__typename"
    )


class DeletePromptInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    promptId: GlobalID
    typename__: Optional[Literal["DeletePromptInput"]] = Field(
        "DeletePromptInput", alias="__typename"
    )


class DeletePromptLabelInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    promptLabelId: GlobalID
    typename__: Optional[Literal["DeletePromptLabelInput"]] = Field(
        "DeletePromptLabelInput", alias="__typename"
    )


class DeletePromptVersionTagInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    promptVersionTagId: GlobalID
    typename__: Optional[Literal["DeletePromptVersionTagInput"]] = Field(
        "DeletePromptVersionTagInput", alias="__typename"
    )


class DeleteUsersInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    userIds: list[GlobalID]
    typename__: Optional[Literal["DeleteUsersInput"]] = Field(
        "DeleteUsersInput", alias="__typename"
    )


class DimensionFilter(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    dataTypes: Optional[list[DimensionDataType]] = None
    shapes: Optional[list[DimensionShape]] = None
    types: Optional[list[DimensionType]] = None
    typename__: Optional[Literal["DimensionFilter"]] = Field(
        "DimensionFilter", alias="__typename"
    )


class DimensionInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: String
    type: DimensionType
    typename__: Optional[Literal["DimensionInput"]] = Field(
        "DimensionInput", alias="__typename"
    )


class EvalResultKey(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    attr: EvalAttr
    name: String
    typename__: Optional[Literal["EvalResultKey"]] = Field(
        "EvalResultKey", alias="__typename"
    )


class GenerativeModelInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    apiVersion: Optional[String] = None
    baseUrl: Optional[String] = None
    endpoint: Optional[String] = None
    name: String
    providerKey: GenerativeProviderKey
    typename__: Optional[Literal["GenerativeModelInput"]] = Field(
        "GenerativeModelInput", alias="__typename"
    )


class Granularity(BaseModel):
    """
    Granularity specifies the distance between points in a time-series and the duration of time (i.e. evaluation window) by which data is aggregated for  each data point. By convention all time intervals are right-open intervals, i.e. the end instant of the evaluation window is excluded from the interval. As a matter of standardization, each point in a time-series aggregates data  corresponding to an interval of time (i.e. the evaluation window) ending at the point's timestamp, and each time-series enumerates its points starting from the end instant of the TimeRange.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    evaluationWindowMinutes: Int = Field(
        ...,
        description=(
            "Specifies the length of time by which the data are grouped for"
            " aggregation. Each point in a time-series will have the same"
            " evaluation_window, but the evaluation_window for each point can overlap"
            " in real time. For example, when the points are 24 hours apart but the"
            " eval window is 72 hours, it means that each point in the time-series is"
            " aggregating 72 hours worth of data ending at the point's timestamp."
        ),
    )
    samplingIntervalMinutes: Int = Field(
        ...,
        description=(
            "Specifies the time interval between each point in the time-series. All"
            " points in the time-series are separated by the same length of time, and"
            " are generated starting from the end time of the time range."
        ),
    )
    typename__: Optional[Literal["Granularity"]] = Field(
        "Granularity", alias="__typename"
    )


class InputCoordinate2D(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    x: Float
    y: Float
    typename__: Optional[Literal["InputCoordinate2D"]] = Field(
        "InputCoordinate2D", alias="__typename"
    )


class InputCoordinate3D(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    x: Float
    y: Float
    z: Float
    typename__: Optional[Literal["InputCoordinate3D"]] = Field(
        "InputCoordinate3D", alias="__typename"
    )


class InvocationParameterInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    canonicalName: Optional[CanonicalParameterName] = None
    invocationName: String
    valueBool: Optional[Boolean] = None
    valueBoolean: Optional[Boolean] = None
    valueFloat: Optional[Float] = None
    valueInt: Optional[Int] = None
    valueJson: Optional[JSON] = None
    valueString: Optional[String] = None
    valueStringList: Optional[list[String]] = None
    typename__: Optional[Literal["InvocationParameterInput"]] = Field(
        "InvocationParameterInput", alias="__typename"
    )


class ModelsInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    modelName: Optional[String] = None
    providerKey: Optional[GenerativeProviderKey] = None
    typename__: Optional[Literal["ModelsInput"]] = Field(
        "ModelsInput", alias="__typename"
    )


class PatchAnnotationInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    annotationId: GlobalID
    annotatorKind: Optional[AnnotatorKind] = None
    explanation: Optional[String] = None
    label: Optional[String] = None
    metadata: Optional[JSON] = None
    name: Optional[String] = None
    score: Optional[Float] = None
    typename__: Optional[Literal["PatchAnnotationInput"]] = Field(
        "PatchAnnotationInput", alias="__typename"
    )


class PatchDatasetExamplesInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    patches: list[DatasetExamplePatch]
    versionDescription: Optional[String] = None
    versionMetadata: Optional[JSON] = None
    typename__: Optional[Literal["PatchDatasetExamplesInput"]] = Field(
        "PatchDatasetExamplesInput", alias="__typename"
    )


class PatchDatasetInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    datasetId: GlobalID
    description: Optional[String] = None
    metadata: Optional[JSON] = None
    name: Optional[String] = None
    typename__: Optional[Literal["PatchDatasetInput"]] = Field(
        "PatchDatasetInput", alias="__typename"
    )


class PatchPromptInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: String
    promptId: GlobalID
    typename__: Optional[Literal["PatchPromptInput"]] = Field(
        "PatchPromptInput", alias="__typename"
    )


class PatchPromptLabelInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    name: Optional[Identifier] = None
    promptLabelId: GlobalID
    typename__: Optional[Literal["PatchPromptLabelInput"]] = Field(
        "PatchPromptLabelInput", alias="__typename"
    )


class PatchUserInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    newPassword: Optional[String] = None
    newRole: Optional[UserRoleInput] = None
    newUsername: Optional[String] = None
    userId: GlobalID
    typename__: Optional[Literal["PatchUserInput"]] = Field(
        "PatchUserInput", alias="__typename"
    )


class PatchViewerInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    currentPassword: Optional[String] = None
    newPassword: Optional[String] = None
    newUsername: Optional[String] = None
    typename__: Optional[Literal["PatchViewerInput"]] = Field(
        "PatchViewerInput", alias="__typename"
    )


class PerformanceMetricInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    metric: PerformanceMetric
    typename__: Optional[Literal["PerformanceMetricInput"]] = Field(
        "PerformanceMetricInput", alias="__typename"
    )


class ProjectSessionSort(BaseModel):
    """
    The sort key and direction for ProjectSession connections.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    col: ProjectSessionColumn
    dir: SortDir
    typename__: Optional[Literal["ProjectSessionSort"]] = Field(
        "ProjectSessionSort", alias="__typename"
    )


class PromptChatTemplateInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    messages: list[PromptMessageInput]
    typename__: Optional[Literal["PromptChatTemplateInput"]] = Field(
        "PromptChatTemplateInput", alias="__typename"
    )


class PromptMessageInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    content: list[ContentPartInput]
    role: String
    typename__: Optional[Literal["PromptMessageInput"]] = Field(
        "PromptMessageInput", alias="__typename"
    )


class PromptTemplateOptions(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    format: PromptTemplateFormat
    variables: JSON
    typename__: Optional[Literal["PromptTemplateOptions"]] = Field(
        "PromptTemplateOptions", alias="__typename"
    )


class ResponseFormatInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    definition: JSON
    typename__: Optional[Literal["ResponseFormatInput"]] = Field(
        "ResponseFormatInput", alias="__typename"
    )


class SetPromptLabelInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    promptId: GlobalID
    promptLabelId: GlobalID
    typename__: Optional[Literal["SetPromptLabelInput"]] = Field(
        "SetPromptLabelInput", alias="__typename"
    )


class SetPromptVersionTagInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    description: Optional[String] = None
    name: Identifier
    promptVersionId: GlobalID
    typename__: Optional[Literal["SetPromptVersionTagInput"]] = Field(
        "SetPromptVersionTagInput", alias="__typename"
    )


class SpanAnnotationSort(BaseModel):
    """
    The sort key and direction for SpanAnnotation connections
    """

    model_config = ConfigDict(
        frozen=True,
    )
    col: SpanAnnotationColumn
    dir: SortDir
    typename__: Optional[Literal["SpanAnnotationSort"]] = Field(
        "SpanAnnotationSort", alias="__typename"
    )


class SpanSort(BaseModel):
    """
    The sort key and direction for span connections. Must specify one and only one of either `col` or `evalResultKey`.
    """

    model_config = ConfigDict(
        frozen=True,
    )
    col: Optional[SpanColumn] = None
    dir: SortDir
    evalResultKey: Optional[EvalResultKey] = None
    typename__: Optional[Literal["SpanSort"]] = Field("SpanSort", alias="__typename")


class TextContentValueInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    text: String
    typename__: Optional[Literal["TextContentValueInput"]] = Field(
        "TextContentValueInput", alias="__typename"
    )


class TimeRange(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    end: Optional[DateTime] = Field(
        default=None, description="The end of the time range. Right exclusive."
    )
    start: Optional[DateTime] = Field(
        default=None, description="The start of the time range"
    )
    typename__: Optional[Literal["TimeRange"]] = Field("TimeRange", alias="__typename")


class ToolCallContentValueInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    toolCall: ToolCallFunctionInput
    toolCallId: String
    typename__: Optional[Literal["ToolCallContentValueInput"]] = Field(
        "ToolCallContentValueInput", alias="__typename"
    )


class ToolCallFunctionInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    arguments: String
    name: String
    type: Optional[String] = "function"
    typename__: Optional[Literal["ToolCallFunctionInput"]] = Field(
        "ToolCallFunctionInput", alias="__typename"
    )


class ToolDefinitionInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    definition: JSON
    typename__: Optional[Literal["ToolDefinitionInput"]] = Field(
        "ToolDefinitionInput", alias="__typename"
    )


class ToolResultContentValueInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    result: JSON
    toolCallId: String
    typename__: Optional[Literal["ToolResultContentValueInput"]] = Field(
        "ToolResultContentValueInput", alias="__typename"
    )


class TraceAnnotationSort(BaseModel):
    """
    The sort key and direction for TraceAnnotation connections
    """

    model_config = ConfigDict(
        frozen=True,
    )
    col: TraceAnnotationColumn
    dir: SortDir
    typename__: Optional[Literal["TraceAnnotationSort"]] = Field(
        "TraceAnnotationSort", alias="__typename"
    )


class UnsetPromptLabelInput(BaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    promptId: GlobalID
    promptLabelId: GlobalID
    typename__: Optional[Literal["UnsetPromptLabelInput"]] = Field(
        "UnsetPromptLabelInput", alias="__typename"
    )


Bin: TypeAlias = Union[
    "IntervalBin",
    "MissingValueBin",
    "NominalBin",
]


ChatCompletionMutationPayloadChatCompletionMutationError: TypeAlias = Union[
    "ChatCompletionMutationError",
    "ChatCompletionMutationPayload",
]


ContentPart: TypeAlias = Union[
    "TextContentPart",
    "ToolCallContentPart",
    "ToolResultContentPart",
]


InvocationParameter: TypeAlias = Union[
    "BooleanInvocationParameter",
    "BoundedFloatInvocationParameter",
    "FloatInvocationParameter",
    "IntInvocationParameter",
    "JSONInvocationParameter",
    "StringInvocationParameter",
    "StringListInvocationParameter",
]


Point2DPoint3D: TypeAlias = Union[
    "Point2D",
    "Point3D",
]


PromptTemplate: TypeAlias = Union[
    "PromptChatTemplate",
    "PromptStringTemplate",
]
